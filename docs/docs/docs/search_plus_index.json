{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction https://qgao233.github.io/qgaoAlgorithms Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-19 18:45:40 "},"chapter1/section1/":{"url":"chapter1/section1/","title":"动态规划","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 斐波那契数列 凑零钱问题 股票买卖 打家劫舍 背包 0-1 背包 部分背包 完全背包 下降路径最小和 最小编辑距离 最大子数组 动态规划 斐波那契数列 int fib(int N) { if (N memo(N + 1, 0); // 初始化最简情况 return helper(memo, N); } int helper(vector& memo, int n) { // base case if (n == 1 || n == 2) return 1; // 已经计算过 if (memo[n] != 0) return memo[n]; memo[n] = helper(memo, n - 1) + helper(memo, n - 2); return memo[n]; } 凑零钱问题 def coinChange(coins: List[int], amount: int): # 备忘录 memo = dict() def dp(n): # 查备忘录，避免重复计算 if n in memo: return memo[n] if n == 0: return 0 if n 股票买卖 一次交易由买入和卖出构成，至少需要两天。所以说有效的限制次数 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。 第一题是只进行一次交易，相当于 k = 1； 第二题是不限交易次数，相当于 k = +infinity（正无穷）； 第三题是只进行 2 次交易，相当于 k = 2； 剩下两道也是不限交易次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今已经进行了 2 次交易。 int maxProfit_k_any(int max_k, int[] prices) { int n = prices.length; if (max_k > n / 2) return maxProfit_k_inf(prices); int[][][] dp = new int[n][max_k + 1][2]; for (int i = 0; i = 1; k--) { if (i - 1 == -1) { dp[i][k][0] = 0; dp[i][k][1] = - prices[i]; continue; } dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-l][k-1][0] - prices[i]); } } return dp[n - 1] [max_k] [0]; } 打家劫舍 198 class Solution { public int rob(int[] nums) { if(nums.length == 1){ return nums[0]; } else if(nums.length == 2){ return Math.max(nums[0],nums[1]); } int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(nums[0],nums[1]); for (int i = 2; i 背包 0-1 背包 给你一个可装载重量为W的背包和N个物品，每个物品有重量和价值两个属性。其中第i个物品的重量为wt[i]，价值为val[i]，现在让你用这个背包装物品，最多能装的价值是多少？ 举个简单的例子，输入如下： N = 3, W = 4 wt = [2, 1, 3] val = [4, 2, 3] 算法返回 6，选择前两件物品装进背包，总重量 3 小于W，可以获得最大价值 6。 dp[i][w]的定义如下：对于前i个物品，当前背包的总容量为w，这种情况下可以装的最大价值是dp[i][w]。 int knapsack(int W, int N, vector& wt, vector& val) { // vector 全填入 0，base case 已初始化 vector> dp(N + 1, vector(W + 1, 0)); for (int i = 1; i 部分背包 力扣第416：将一个数组分割成两个等和的子集。 假设背包只能装一半，能否刚好装齐 dp[i][j] = x表示，对于前i个物品，当前背包的容量为j时，若x为true，则说明可以恰好将背包装满，若x为false，则说明不能恰好将背包装满。 base case 为true：当容量为0时，某种含义表示已被装满，因此为true bool canPartition(vector& nums) { int sum = 0; for (int num : nums) sum += num; // 和为奇数时，不可能划分成两个和相等的集合 if (sum % 2 != 0) return false; int n = nums.size(); sum = sum / 2; vector> dp(n + 1, vector(sum + 1, false)); // base case for (int i = 0; i 状态压缩后：注意到dp[i][j]都是通过上一行dp[i-1][..]转移过来的，也就是说，实际上一直是两行的数据在轮替。 j要反着遍历：dp数组其实是起着一个备忘录的作用，解决重叠子问题， 如果正着遍历，某一个dp[j]【A】通过上一行的数据计算过后，之后若有别的dp[j]【B】要通过上一行的A来更新的话，但实际上获得的却是这一行重新更新后的A，与题意不符， 但如果是反着遍历，那么当前行的更新永远都是通过上一行的数据进行的更新。 bool canPartition(vector& nums) { int sum = 0, n = nums.size(); for (int num : nums) sum += num; if (sum % 2 != 0) return false; sum = sum / 2; vector dp(sum + 1, false); // base case dp[0] = true; for (int i = 0; i = 0; j--) if (j - nums[i] >= 0) dp[j] = dp[j] || dp[j - nums[i]]; return dp[sum]; } 完全背包 LeetCode 第 518 题，凑零钱2 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数，假设每一种面额的硬币有无限个。 换句话说，有一个背包，最大容量为amount，有一系列物品coins，每个物品的重量为coins[i]，每个物品的数量无限。请问有多少种方法，能够把背包恰好装满？ 和之前的两个背包问题，有一个最大的区别就是，每个物品的数量是无限的，这也就是传说中的「完全背包问题」 dp[i][j]的定义如下： 若只使用前i个物品，当背包容量为j时，有dp[i][j]种方法可以装满背包。 换句话说，翻译回我们题目的意思就是： 若只使用coins中的前i个硬币的面值，若想凑出金额j，有dp[i][j]种凑法。 经过以上的定义，可以得到： base case 为： dp[0][..] = 0，如果不使用任何硬币面值，就无法凑出任何金额； dp[..][0] = 1，如果凑出的目标金额为 0，那么“无为而治”就是唯一的一种凑法。 我们最终想得到的答案就是dp[N][amount]，其中N为coins数组的大小。 int change(int amount, int[] coins) { int n = coins.length; int[][] dp = amount int[n + 1][amount + 1]; // base case for (int i = 0; i = 0) dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i-1]]; else dp[i][j] = dp[i - 1][j]; } return dp[n][amount]; } 状态压缩： int change(int amount, int[] coins) { int n = coins.length; int[] dp = new int[amount + 1]; dp[0] = 1; // base case for (int i = 0; i = 0) dp[j] = dp[j] + dp[j-coins[i]]; return dp[amount]; } 下降路径最小和 力扣第 931 题 从第一行matrix[0][..]向下落，落到位置matrix[i][j]的最小路径和为dp(matrix, i, j)。 public int minFallingPathSum(int[][] matrix) { int n = matrix.length; int res = Integer.MAX_VALUE; // 备忘录里的值初始化为 66666 memo = new int[n][n]; for (int i = 0; i = matrix.length || j >= matrix[0].length) { return 99999; } // 2、base case if (i == 0) { return matrix[0][j]; } // 3、查找备忘录，防止重复计算 if (memo[i][j] != 66666) { return memo[i][j]; } // 进行状态转移 memo[i][j] = matrix[i][j] + min( dp(matrix, i - 1, j), dp(matrix, i - 1, j - 1), dp(matrix, i - 1, j + 1) ); return memo[i][j]; } int min(int a, int b, int c) { return Math.min(a, Math.min(b, c)); } 最小编辑距离 dp[i-1][j-1] # 存储 s1[0..i] 和 s2[0..j] 的最小编辑距离 int minDistance(String s1, String s2) { int m = s1.length(), n = s2.length(); int[][] dp = new int[m + 1][n + 1]; // base case for(int i = 1; i // int[][] dp; Node[][] dp; class Node { int val; int choice; // 0 代表啥都不做 // 1 代表插入 // 2 代表删除 // 3 代表替换 } 最大子数组 以nums[i]为结尾的「最大子数组和」为dp[i] dp[i]有两种「选择」， 要么与前面的相邻子数组连接，形成一个和更大的子数组； 要么不与前面的子数组连接，自成一派，自己作为一个子数组。 int maxSubArray(int[] nums) { int n = nums.length; if (n == 0) return 0; int[] dp = new int[n]; // base case // 第一个元素前面没有子数组 dp[0] = nums[0]; // 状态转移方程 for (int i = 1; i Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-16 20:02:04 "},"chapter1/section2/":{"url":"chapter1/section2/","title":"回溯","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 全排列 组合：求子集 N皇后 回溯 全排列 // 路径：记录在 track 中 // 选择列表：nums 中不存在于 track 的那些元素 // 结束条件：nums 中的元素全都在 track 中出现 void backtrack(int[] nums, LinkedList track) { // 触发结束条件 if (track.size() == nums.length) { res.add(new LinkedList(track)); return; } for (int i = 0; i 组合：求子集 ①数学归纳：在之前的每一个子集中加入当前元素，然后添加到之前的子集的集合中。 ②回溯 vector> res; vector> subsets(vector& nums) { // 记录走过的路径 vector track; backtrack(nums, 0, track); return res; } void backtrack(vector& nums, int start, vector& track) { res.push_back(track); // 注意 i 从 start 开始递增 for (int i = start; i N皇后 给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。 PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。 // 路径：board 中小于 row 的那些行都已经成功放置了皇后 // 选择列表：第 row 行的所有列都是放置皇后的选择 // 结束条件：row 超过 board 的最后一行 void backtrack(vector& board, int row) { // 触发结束条件 if (row == board.size()) { res.push_back(board); return; } int n = board[row].size(); for (int col = 0; col & board, int row, int col) { int n = board.size(); // 检查列是否有皇后互相冲突 for (int i = 0; i = 0 && j = 0 && j >= 0; i--, j--) { if (board[i][j] == 'Q') return false; } return true; } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-06 15:35:47 "},"chapter1/section3/":{"url":"chapter1/section3/","title":"bfs","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 二叉树的最小高度 解开密码锁的最少次数 bfs 二叉树的最小高度 LeetCode 第 111 题 int minDepth(TreeNode root) { if (root == null) return 0; Queue q = new LinkedList<>(); q.offer(root); // root 本身就是一层，depth 初始化为 1 int depth = 1; while (!q.isEmpty()) { int sz = q.size(); /* 将当前队列中的所有节点向四周扩散 */ for (int i = 0; i 解开密码锁的最少次数 LeetCode 题目是第 752 题 int openLock(String[] deadends, String target) { // 记录需要跳过的死亡密码 Set deads = new HashSet<>(); for (String s : deadends) deads.add(s); // 记录已经穷举过的密码，防止走回头路 Set visited = new HashSet<>(); Queue q = new LinkedList<>(); // 从起点开始启动广度优先搜索 int step = 0; q.offer(\"0000\"); visited.add(\"0000\"); while (!q.isEmpty()) { int sz = q.size(); /* 将当前队列中的所有节点向周围扩散 */ for (int i = 0; i Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-06 10:18:17 "},"chapter1/section4/":{"url":"chapter1/section4/","title":"滑动窗口","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 最小覆盖子串 字符串排列 找所有字母异位词 最长无重复子串 滑动窗口 最小覆盖子串 LeetCode 76 题 string minWindow(string s, string t) { unordered_map need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; // 记录最小覆盖子串的起始索引及长度 int start = 0, len = INT_MAX; while (right 字符串排列 LeetCode 567 题 // 判断 s 中是否存在 t 的排列 bool checkInclusion(string t, string s) { unordered_map need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; while (right = t.size()) { // 在这里判断是否找到了合法的子串 if (valid == need.size()) return true; char d = s[left]; left++; // 进行窗口内数据的一系列更新 if (need.count(d)) { if (window[d] == need[d]) valid--; window[d]--; } } } // 未找到符合条件的子串 return false; } 找所有字母异位词 LeetCode 第 438 题 vector findAnagrams(string s, string t) { unordered_map need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; vector res; // 记录结果 while (right = t.size()) { // 当窗口符合条件时，把起始索引加入 res if (valid == need.size()) res.push_back(left); char d = s[left]; left++; // 进行窗口内数据的一系列更新 if (need.count(d)) { if (window[d] == need[d]) valid--; window[d]--; } } } return res; } 最长无重复子串 LeetCode 第 3 题 int lengthOfLongestSubstring(string s) { unordered_map window; int left = 0, right = 0; int res = 0; // 记录结果 while (right 1) { char d = s[left]; left++; // 进行窗口内数据的一系列更新 window[d]--; } // 在这里更新答案 res = max(res, right - left); } return res; } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-06 10:18:50 "},"chapter1/section5/":{"url":"chapter1/section5/","title":"树","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 最近公共祖先 翻转二叉树 填充二叉树节点的右侧next指针 将二叉树展开为链表 构造最大二叉树 中序和先序构造二叉树 寻找重复子树 二叉搜索树中第K小的元素 BST 转化累加树 验证bst的合法性 bst 中插入一个数 bst删除一个数 不同的二叉搜索树1 不同的二叉搜索树2 二叉搜索子树的最大键值和 二叉树的序列化与反序列化 扁平化嵌套列表迭代器 完全二叉树的结点个数 树 最近公共祖先 LeetCode 上第 236 题 //找结点p或q是否在以root为根的树中 TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { // base case if (root == null) return null; if (root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); // 情况 1,一个结点在左子树,一个结点在右子树(11) if (left != null && right != null) { return root; } // 情况 2,不在左子树,也不在右子树(00) if (left == null && right == null) { return null; } // 情况 3,在左子树或右子树(10 || 01) return left != null ? left : right; } 如果只有一个结点在root为根的树上,只会返回那个结点。 翻转二叉树 力扣第 226 题 // 将整棵树的节点翻转 TreeNode invertTree(TreeNode root) { // base case if (root == null) { return null; } /**** 前序遍历位置 ****/ // root 节点需要交换它的左右子节点 TreeNode tmp = root.left; root.left = root.right; root.right = tmp; // 让左右子节点继续翻转它们的子节点 invertTree(root.left); invertTree(root.right); return root; } 填充二叉树节点的右侧next指针 力扣第 116 题 // 主函数 Node connect(Node root) { if (root == null) return null; connectTwoNode(root.left, root.right); return root; } // 定义：输入两个节点，将它俩连接起来 void connectTwoNode(Node node1, Node node2) { if (node1 == null || node2 == null) { return; } /**** 前序遍历位置 ****/ // 将传入的两个节点连接 node1.next = node2; // 连接相同父节点的两个子节点 connectTwoNode(node1.left, node1.right); connectTwoNode(node2.left, node2.right); // 连接跨越父节点的两个子节点 connectTwoNode(node1.right, node2.left); } 将二叉树展开为链表 力扣第 114 题 // 定义：将以 root 为根的树拉平为链表 void flatten(TreeNode root) { // base case if (root == null) return; flatten(root.left); flatten(root.right); /**** 后序遍历位置 ****/ // 1、左右子树已经被拉平成一条链表 TreeNode tmpLeft = root.left; TreeNode tmpRight = root.right; // 2、将左子树作为右子树 root.left = null; root.right = tmpLeft; // 3、将原先的右子树接到当前右子树的末端 TreeNode p = root; while (p.right != null) { p = p.right; } p.right = tmpRight; } 构造最大二叉树 力扣第 654 题 /* 将 nums[lo..hi] 构造成符合条件的树，返回根节点 */ TreeNode build(int[] nums, int lo, int hi) { // base case if (lo > hi) { return null; } // 找到数组中的最大值和对应的索引 int index = -1, maxVal = Integer.MIN_VALUE; for (int i = lo; i 中序和先序构造二叉树 TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) { if (preStart > preEnd) { return null; } // root 节点对应的值就是前序遍历数组的第一个元素 int rootVal = preorder[preStart]; // rootVal 在中序遍历数组中的索引 int index = 0; for (int i = inStart; i 寻找重复子树 主要是要通过“后序”的方式把一棵树描述下来。才好用字符串对比。 // 记录所有子树以及出现的次数 HashMap memo = new HashMap<>(); // 记录重复的子树根节点 LinkedList res = new LinkedList<>(); /* 主函数 */ List findDuplicateSubtrees(TreeNode root) { traverse(root); return res; } /* 辅助函数 */ String traverse(TreeNode root) { if (root == null) { return \"#\"; } String left = traverse(root.left); String right = traverse(root.right); String subTree = left + \",\" + right+ \",\" + root.val; int freq = memo.getOrDefault(subTree, 0); // 多次重复也只会被加入结果集一次 if (freq == 1) { res.add(root); } // 给子树对应的出现次数加一 memo.put(subTree, freq + 1); return subTree; } 二叉搜索树中第K小的元素 力扣第 230 题 int kthSmallest(TreeNode root, int k) { // 利用 BST 的中序遍历特性 traverse(root, k); return res; } // 记录结果 int res = 0; // 记录当前元素的排名 int rank = 0; void traverse(TreeNode root, int k) { if (root == null) { return; } traverse(root.left, k); /* 中序遍历代码位置 */ rank++; if (k == rank) { // 找到第 k 小的元素 res = root.val; return; } /*****************/ traverse(root.right, k); } BST 转化累加树 力扣第 538 题和 1038 题 // 记录累加和 int sum = 0; void traverse(TreeNode root) { if (root == null) { return; } traverse(root.right); // 维护累加和 sum += root.val; // 将 BST 转化成累加树 root.val = sum; traverse(root.left); } 验证bst的合法性 public boolean isValidBST(TreeNode root) { return isValid(root, null, null); } //左子树中最大的值 = min.val) return false; return isValid(node.left, max, node) && isValid(node.right, node, min); } bst 中插入一个数 TreeNode insertIntoBST(TreeNode root, int val) { // 找到空位置插入新节点 if (root == null) return new TreeNode(val); // if (root.val == val) // BST 中一般不会插入已存在元素 if (root.val val) root.left = insertIntoBST(root.left, val); return root; } bst删除一个数 情况 3：A有两个子节点，麻烦了，为了不破坏 BST 的性质，A必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。 TreeNode deleteNode(TreeNode root, int key) { if (root == null) return null; if (root.val == key) { // 这两个 if 把情况 1 和 2 都正确处理了 if (root.left == null) return root.right; if (root.right == null) return root.left; // 处理情况 3,找右子树中最小的那个节点来接替自己 TreeNode minNode = getMin(root.right); root.val = minNode.val; root.right = deleteNode(root.right, minNode.val); } else if (root.val > key) { root.left = deleteNode(root.left, key); } else if (root.val 不同的二叉搜索树1 力扣第 96 题，只用计算数量。 n=5时，以3为根能构造成的个数 // 备忘录 int[][] memo; int numTrees(int n) { // 备忘录的值初始化为 0 memo = new int[n + 1][n + 1]; return count(1, n); } int count(int lo, int hi) { if (lo > hi) return 1; // 查备忘录 if (memo[lo][hi] != 0) { return memo[lo][hi]; } int res = 0; for (int mid = lo; mid 不同的二叉搜索树2 力扣第 95 题，返回构成的不同的树的列表 /* 主函数 */ public List generateTrees(int n) { if (n == 0) return new LinkedList<>(); // 构造闭区间 [1, n] 组成的 BST return build(1, n); } /* 构造闭区间 [lo, hi] 组成的 BST */ List build(int lo, int hi) { List res = new LinkedList<>(); // base case if (lo > hi) { res.add(null); return res; } // 1、穷举 root 节点的所有可能。 for (int i = lo; i leftTree = build(lo, i - 1); List rightTree = build(i + 1, hi); // 3、给 root 节点穷举所有左右子树的组合。 for (TreeNode left : leftTree) { for (TreeNode right : rightTree) { // i 作为根节点 root 的值 TreeNode root = new TreeNode(i); root.left = left; root.right = right; res.add(root); } } } return res; } 二叉搜索子树的最大键值和 力扣第 1373 题 算法返回20 任何一个单独的节点肯定是 BST，也就是说，再不济，二叉树最下面的叶子节点肯定是 BST。 traverse(root)返回一个大小为 4 的 int 数组，我们暂且称它为res，其中： res[0]记录以root为根的二叉树是否是 BST，若为 1 则说明是 BST，若为 0 则说明不是 BST； res[1]记录以root为根的二叉树所有节点中的最小值； res[2]记录以root为根的二叉树所有节点中的最大值； res[3]记录以root为根的二叉树所有节点值之和。 int[] traverse(TreeNode root) { // base case if (root == null) { return new int[] { 1, Integer.MAX_VALUE, Integer.MIN_VALUE, 0 }; } // 递归计算左右子树 int[] left = traverse(root.left); int[] right = traverse(root.right); /******* 后序遍历位置 *******/ int[] res = new int[4]; // 这个 if 在判断以 root 为根的二叉树是不是 BST if (left[0] == 1 && right[0] == 1 && root.val > left[2] && root.val 二叉树的序列化与反序列化 中序遍历无法反序列化 String Serialize(TreeNode root) { //遇到null怎么办 if(root==null){ return \"X,\"; } String left=Serialize(root.left); String right=Serialize(root.right); return root.val+\",\"+left+right; } TreeNode Deserialize(String str) { String[] nodes=str.split(\",\"); //将String数组转换为list Deque deque=new LinkedList<>(Arrays.asList(nodes)); return buildTree(deque); } TreeNode buildTree(Deque dq){ String var=dq.poll(); //若为X，说明为空节点 if(var.equals(\"X\")){ return null; } TreeNode root=new TreeNode(Integer.parseInt(var)); root.left=buildTree(dq); root.right=buildTree(dq); return root; } 扁平化嵌套列表迭代器 LeetCode 第 341 题 public class NestedInteger { private Integer val; private List list; public NestedInteger(Integer val) { this.val = val; this.list = null; } public NestedInteger(List list) { this.list = list; this.val = null; } // 如果其中存的是一个整数，则返回 true，否则返回 false public boolean isInteger() { return val != null; } // 如果其中存的是一个整数，则返回这个整数，否则返回 null public Integer getInteger() { return this.val; } // 如果其中存的是一个列表，则返回这个列表，否则返回 null public List getList() { return this.list; } } public class NestedIterator implements Iterator { private LinkedList list; public NestedIterator(List nestedList) { // 不直接用 nestedList 的引用，是因为不能确定它的底层实现 // 必须保证是 LinkedList，否则下面的 addFirst 会很低效 list = new LinkedList<>(nestedList); } public Integer next() { // hasNext 方法保证了第一个元素一定是整数类型 return list.remove(0).getInteger(); } public boolean hasNext() { // 循环拆分列表元素，直到列表第一个元素是整数类型 while (!list.isEmpty() && !list.get(0).isInteger()) { // 当列表开头第一个元素是列表类型时，进入循环 List first = list.remove(0).getList(); // 将第一个列表打平并按顺序添加到开头 for (int i = first.size() - 1; i >= 0; i--) { list.addFirst(first.get(i)); } } return !list.isEmpty(); } } 完全二叉树的结点个数 关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发hl == hr而立即返回，不会递归下去。 一棵完全二叉树的两棵子树，至少有一棵是满二叉树： public int countNodes(TreeNode root) { TreeNode l = root, r = root; // 记录左、右子树的高度 int hl = 0, hr = 0; while (l != null) { l = l.left; hl++; } while (r != null) { r = r.right; hr++; } // 如果左右子树的高度相同，则是一棵满二叉树 if (hl == hr) { return (int)Math.pow(2, hl) - 1; } // 如果左右高度不同，则按照普通二叉树的逻辑计算 return 1 + countNodes(root.left) + countNodes(root.right); } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-06 10:19:41 "},"chapter1/section6/":{"url":"chapter1/section6/","title":"图","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 所有可能路径 课程表（有向图中是否存在环） 课程表 II（拓扑排序） 名流问题 图 所有可能路径 力扣第 797 题 输入的图是无环的，不需要visited数组辅助 // 记录所有路径 List> res = new LinkedList<>(); public List> allPathsSourceTarget(int[][] graph) { LinkedList path = new LinkedList<>(); traverse(graph, 0, path); return res; } /* 图的遍历框架 */ void traverse(int[][] graph, int s, LinkedList path) { // 添加节点 s 到路径 path.addLast(s); int n = graph.length; if (s == n - 1) { // 到达终点 res.add(new LinkedList<>(path)); path.removeLast(); return; } // 递归每个相邻节点 for (int v : graph[s]) { traverse(graph, v, path); } // 从路径移出节点 s path.removeLast(); } 课程表（有向图中是否存在环） 力扣第 207 题：判断是否能完成所有课程 visited数组是用来剪枝的，在代码中是全局变量，并且只赋值true，而没有像onPath一样有回溯操作（即onPath【s】=false），举个例值，有a，b两个节点都有一条到c的路径，那么a判断之后被标记了visited【s】=true，b再去遍历的时候可以直接返回。 onPath是记录回溯的路径的，是检查环是否存在的重要标志！ 经过测试，只有OnPath没有visited，在100个节点的时候就会超时。 // 记录一次 traverse 递归经过的节点 boolean[] onPath; // 记录遍历过的节点，防止走回头路 boolean[] visited; // 记录图中是否有环 boolean hasCycle = false; boolean canFinish(int numCourses, int[][] prerequisites) { List[] graph = buildGraph(numCourses, prerequisites); visited = new boolean[numCourses]; onPath = new boolean[numCourses]; for (int i = 0; i [] graph, int s) { if (onPath[s]) { // 出现环 hasCycle = true; } if (visited[s] || hasCycle) { // 如果之前已经遍历过了，或找到了环，也不用再遍历了 return; } // 前序遍历代码位置 visited[s] = true; onPath[s] = true; for (int t : graph[s]) { traverse(graph, t); } // 后序遍历代码位置 onPath[s] = false; } List[] buildGraph(int numCourses, int[][] prerequisites) { // 图中共有 numCourses 个节点 List[] graph = new LinkedList[numCourses]; for (int i = 0; i (); } for (int[] edge : prerequisites) { int from = edge[1]; int to = edge[0]; // 修完课程 from 才能修课程 to // 在图中添加一条从 from 指向 to 的有向边 graph[from].add(to); } return graph; } 课程表 II（拓扑排序） 力扣第 210 题：完成所有课程完排的学习顺序 后序遍历的结果进行反转，就是拓扑排序的结果 boolean[] visited; // 记录后序遍历结果，存的是to->from，因此要反转 List postorder = new ArrayList<>(); int[] findOrder(int numCourses, int[][] prerequisites) { // 先保证图中无环 if (!canFinish(numCourses, prerequisites)) { return new int[]{}; } // 建图 List[] graph = buildGraph(numCourses, prerequisites); // 进行 DFS 遍历 visited = new boolean[numCourses]; for (int i = 0; i [] graph, int s) { if (visited[s]) { return; } visited[s] = true; for (int t : graph[s]) { traverse(graph, t); } // 后序遍历位置 postorder.add(s); } // 参考上一题的解法 boolean canFinish(int numCourses, int[][] prerequisites); // 参考前文代码 List[] buildGraph(int numCourses, int[][] prerequisites); 名流问题 力扣第 277 题 所谓「名人」的定义： 1、所有其他人都认识名人。 2、名人不认识任何其他人。 int findCelebrity(int n) { // 先假设 cand 是名人 int cand = 0; // 循环一次，两两进行比较，淘汰不可能是名人的人 for (int other = 1; other Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-06 10:20:21 "},"chapter1/section7/":{"url":"chapter1/section7/","title":"链表","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 递归反转链表 k个一组反转链表 判断回文单链表 链表 递归反转链表 ListNode reverse(ListNode head) { if (head.next == null) return head; ListNode headAfterReverse = reverse(head.next); head.next.next = head; head.next = null; return headAfterReverse; } 反转一部分： ListNode successor = null; // 后驱节点 // 反转以 head 为起点的 n 个节点，返回新的头结点 ListNode reverseN(ListNode head, int n) { if (n == 1) { // 记录第 n + 1 个节点 successor = head.next; return head; } // 以 head.next 为起点，需要反转前 n - 1 个节点 ListNode last = reverseN(head.next, n - 1); head.next.next = head; // 让反转之后的 head 节点和后面的节点连起来 head.next = successor; return last; } ListNode reverseBetween(ListNode head, int m, int n) { // base case if (m == 1) { return reverseN(head, n); } // 前进到反转的起点触发 base case head.next = reverseBetween(head.next, m - 1, n - 1); return head; } k个一组反转链表 ListNode reverseKGroup(ListNode head, int k) { if (head == null) return null; // 区间 [a, b) 包含 k 个待反转元素 ListNode a, b; a = b = head; for (int i = 0; i 判断回文单链表 第一种方法：递归 // 左侧指针 ListNode left; boolean isPalindrome(ListNode head) { left = head; return traverse(head); } boolean traverse(ListNode right) { if (right == null) return true; boolean res = traverse(right.next); // 后序遍历代码 res = res && (right.val == left.val); left = left.next; return res; } 第二种方法：快慢指针找中点，然后反转中点后的链表，再进行比较 boolean isPalindrome(ListNode head) { ListNode left = head; ListNode right = reverse(slow); while(right != null) { if(left.val != right.val) return false; left = left.next; right = right.next; } return true; } ListNode reverse(ListNode head) { ListNode pre = null, cur = head; while (cur != null) { ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; } return pre; } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-06 10:20:46 "},"chapter1/section8/":{"url":"chapter1/section8/","title":"子序列（动态规划）","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 最长递增子序列 信封嵌套 最长公共子序列（长度） 最长回文子序列 子序列（动态规划） 最长递增子序列 ①动态规划：在子数组array[0..i]中，以array[i]结尾的目标子序列（最长递增子序列）的长度是dp[i]。 public int lengthofLIS(int[] nums) { int[] dp = new int[nums.length]; // base case 全部初始化为1 Arrays.fill(dp, 1); for (int i = 0; i ②扑克牌游戏解释了二分查找解法 信封嵌套 // envelopes = [[w, h], [w, h]...] public int maxEnvelopes(int[][] envelopes) { int n = envelopes.length; //按宽度升序排列，如果宽度一样，则按高度降序排列 Arrays.sort(envelopes, new Comparator(){ public int compare(int[] a, int[] b) { return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]; } })； //对高度数组寻找LIS int[] height = new int[n]; for (int i = 0; i 最长公共子序列（长度） 在子数组arr1[0..i]和子数组arr2[0..j]中，我们要求的子序列（最长公共子序列）长度为dp[i][j]。 dp[0][..]和dp[..][0]都应该初始化为 0，这就是 base case。 int[][] longestCommonSubsequence(String str1, String str2) { int m = str1.length(), n = str2.length(); //DP table base case int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i 最长回文子序列 在子数组array[i..j]中，我们要求的子序列（最长回文子序列）的长度为dp[i][j]。 base case，如果只有一个字符，显然最长回文子序列长度是 1，也就是dp[i][j] = 1,(i == j) 为了保证每次计算dp[i][j]，左、下、左下三个方向的位置已经被计算出来，只能斜着遍历或者反着遍历： 【斜着遍历】: // 斜着遍历数组 // 第一行的第几列 for (int k = 2; k 【反着遍历】： int longestPalindromeSubseq(string s) { int n = s.size(); // dp 数组全部初始化为 0 vector> dp(n, vector(n, 0)); // base case for (int i = 0; i = 0; i--) { for (int j = i + 1; j 状态压缩： base case: 投影 状态转移：从二维到一维 dp[j]赋新值之前： dp[j]的值就是外层 for 循环上一次迭代算出来的值，也就是对应二维dp数组中dp[i+1][j]的位置。 dp[j-1]的值就是内层 for 循环上一次迭代算出来的值，也就是对应二维dp数组中dp[i][j-1]的位置。 只要保存dp[j]的值即dp[i+1][j]，到下一轮内层循环时，即j++了，不就变成dp[i+1][j+1]了。 int longestPalindromeSubseq(string s) { int n = s.size(); // base case：一维 dp 数组全部初始化为 1 vector dp(n, 1); for (int i = n - 2; i >= 0; i--) { int pre = 0; for (int j = i + 1; j Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 20:49:42 "},"chapter1/section9/":{"url":"chapter1/section9/","title":"数据结构","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 Union-Find（并查集算法） 删去被包围的O 判定合法算式 LRU LFU 最大频率栈 数据流的中位数 朋友圈时间线 单调栈 下一个更大元素 I 更暖和的气温 下一个更大元素 II 单调队列 滑动窗口最大值 栈实现队列 队列实现栈 数据结构 Union-Find（并查集算法） 解决图论中「动态连通性」问题的 动态连通性：给一幅图中的结点连线 「连通」是一种等价关系，也就是说具有如下三个性质： 1、自反性：节点p和p是连通的。 2、对称性：如果节点p和q连通，那么q和p也连通。 3、传递性：如果节点p和q连通，q和r连通，那么p和r也连通。 连通后的结点形成的组合称为一个连通分量，通过“自反性”知：独立的，出入度皆为0的一个结点也是一个连通分量。 使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个【森林】。 应用场景： 编译器判断同一个变量的不同引用， 社交网络中的朋友圈计算等等。class UF { // 连通分量个数 private int count; // 存储一棵树 private int[] parent; // 记录树的“重量” private int[] size; public UF(int n) { this.count = n; parent = new int[n]; size = new int[n]; for (int i = 0; i size[rootQ]) { parent[rootQ] = rootP; size[rootP] += size[rootQ]; } else { parent[rootP] = rootQ; size[rootQ] += size[rootP]; } count--; } /* 判断 p 和 q 是否互相连通 */ public Boolean connected(int p, int q) { int rootP = find(p); int rootQ = find(q); // 处于同一棵树上的节点，相互连通 return rootP == rootQ; } private int find(int x) { while (parent[x] != x) { // 进行路径压缩，每次调用都会提高找到parent的速度，并且改变parent的指向 关键点2保证了树高为常数（不超过 3） parent[x] = parent[parent[x]]; x = parent[x]; } return x; } } 如果带有重量平衡优化，一定会得到情况一， 而去掉重量优化，可能出现情况二。而此时高度为3，会触发路径压缩那个while循环，会多执行很多次路径压缩，将第三层节点压缩到第二层。 而情况一根本不会触发路径压缩， 也就是说，去掉重量平衡，虽然对于单个的find函数调用，时间复杂度依然是 O(1)，但是对于 API 调用的整个过程，效率会有一定的下降。删去被包围的O 力扣第 130 题 将矩阵中完全被X围住的O替换成X， 边角上的O一定不会被围，进一步，与边角上的O相连的O也不会被X围四面，也不会被替换 传统解法： ①先用 for 循环遍历棋盘的四边，用 DFS 算法把那些与边界相连的O换成一个特殊字符，比如# ②然后再遍历整个棋盘，把剩下的O换成X，把#恢复成O 二维坐标映射到一维的常用技巧：索引从0开始： (x,y) à x*n+y 【m行n列】 使用union-find: void solve(char[][] board) { if (board.length == 0) return; int m = board.length; int n = board[0].length; // 给 dummy 留一个额外位置 UF uf = new UF(m * n + 1); int dummy = m * n; // 将首列和末列的 O 与 dummy 连通 for (int i = 0; i 判定合法算式 Boolean equationsPossible(String[] equations) { // 26 个英文字母 UF uf = new UF(26); // 先让相等的字母形成连通分量 for (String eq : equations) { if (eq.charAt(1) == '=') { char x = eq.charAt(0); char y = eq.charAt(3); uf.union(x - 'a', y - 'a'); } } // 检查不等关系是否打破相等关系的连通性 for (String eq : equations) { if (eq.charAt(1) == '!') { char x = eq.charAt(0); char y = eq.charAt(3); // 如果相等关系成立，就是逻辑冲突 if (uf.connected(x - 'a', y - 'a')) return false; } } return true; } LRU 力扣第 146 题 需要数据结构：LinkedHashMap【put时，是插入尾部】 class LRUCache { int cap; LinkedHashMap linkedHashMap = new LinkedHashMap<>(); public LRUCache(int capacity) { this.cap = capacity; } public int get(int key) { if (!linkedHashMap.containsKey(key)) { return -1; } // 将 key 变为最近使用 makeRecently(key); return linkedHashMap.get(key); } public void put(int key, int val) { if (linkedHashMap.containsKey(key)) { // 修改 key 的值，插入的是双向链表的尾部 linkedHashMap.put(key, val); // 将 key 变为最近使用 makeRecently(key); return; } if (linkedHashMap.size() >= this.cap) { // 链表头部就是最久未使用的 key int oldestKey = linkedHashMap.keySet().iterator().next(); linkedHashMap.remove(oldestKey); } // 将新的 key 添加链表尾部 linkedHashMap.put(key, val); } private void makeRecently(int key) { int val = linkedHashMap.get(key); // 删除 key，重新插入到队尾 linkedHashMap.remove(key); linkedHashMap.put(key, val); } } LFU 淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据。class LFUCache { // key 到 val 的映射，我们后文称为 KV 表 HashMap keyToVal; // key 到 freq 的映射，我们后文称为 KF 表 HashMap keyToFreq; // freq 到 key 列表的映射，我们后文称为 FK 表，freq对key是一对多的关系 HashMap> freqToKeys; // 记录最小的频次，避免遍历一遍去找 int minFreq; // 记录 LFU 缓存的最大容量 int cap; public LFUCache(int capacity) { keyToVal = new HashMap<>(); keyToFreq = new HashMap<>(); freqToKeys = new HashMap<>(); this.cap = capacity; this.minFreq = 0; } public int get(int key) { if (!keyToVal.containsKey(key)) { return -1; } // 增加 key 对应的 freq increaseFreq(key); return keyToVal.get(key); } public void put(int key, int val) { if (this.cap ()); freqToKeys.get(1).add(key); // 插入新 key 后最小的 freq 肯定是 1 this.minFreq = 1; } private void increaseFreq(int key) { int freq = keyToFreq.get(key); /* 更新 KF 表 */ keyToFreq.put(key, freq + 1); /* 更新 FK 表 */ // 将 key 从 freq 对应的列表中删除 freqToKeys.get(freq).remove(key); // 将 key 加入 freq + 1 对应的列表中 freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet<>()); freqToKeys.get(freq + 1).add(key); // 如果 freq 对应的列表空了，移除这个 freq if (freqToKeys.get(freq).isEmpty()) { freqToKeys.remove(freq); // 如果这个 freq 恰好是 minFreq，更新 minFreq if (freq == this.minFreq) { this.minFreq++; } } } private void removeMinFreqKey() { // freq 最小的 key 列表 LinkedHashSet keyList = freqToKeys.get(this.minFreq); // 其中最先被插入的那个 key 即最旧的key，就是该被淘汰的 key int deletedKey = keyList.iterator().next(); /* 更新 FK 表 */ keyList.remove(deletedKey); if (keyList.isEmpty()) { freqToKeys.remove(this.minFreq); // 问：这里需要更新 minFreq 的值吗？ } /* 更新 KV 表 */ keyToVal.remove(deletedKey); /* 更新 KF 表 */ keyToFreq.remove(deletedKey); } } 最大频率栈 力扣第 895 题class FreqStack { // 记录 FreqStack 中元素的最大频率 int maxFreq = 0; // 记录 FreqStack 中每个 val 对应的出现频率，后文就称为 VF 表 HashMap valToFreq = new HashMap<>(); // 记录频率 freq 对应的 val 列表，后文就称为 FV 表 HashMap> freqToVals = new HashMap<>(); // 在栈中加入一个元素 val public void push(int val) { // 修改 VF 表：val 对应的 freq 加一 int freq = valToFreq.getOrDefault(val, 0) + 1; valToFreq.put(val, freq); // 修改 FV 表：在 freq 对应的列表加上 val freqToVals.putIfAbsent(freq, new Stack<>()); freqToVals.get(freq).push(val); // 更新 maxFreq maxFreq = Math.max(maxFreq, freq); } // 从栈中删除并返回出现频率最高的元素 // 如果频率最高的元素不止一个， // 则返回最近添加的那个元素 public int pop() { // 修改 FV 表：pop 出一个 maxFreq 对应的元素 v Stack vals = freqToVals.get(maxFreq); int v = vals.pop(); // 修改 VF 表：v 对应的 freq 减一 int freq = valToFreq.get(v) - 1; valToFreq.put(v, freq); // 更新 maxFreq if (vals.isEmpty()) { // 如果 maxFreq 对应的元素空了 maxFreq--; } return v; } } 数据流的中位数 力扣第 295 题 维护：class ../medianFinder { private PriorityQueue large; private PriorityQueue small; public ../medianFinder() { // 小顶堆，存的是较大的数据 large = new PriorityQueue<>(); // 大顶堆，存的是较小的数据，使用的是Comparator将其变为大根堆 small = new PriorityQueue<>((a, b) -> { return b - a; } ); } public double find../median() { // 如果元素不一样多，多的那个堆的堆顶元素就是中位数 if (large.size() small.size()) { return large.peek(); } // 如果元素一样多，两个堆堆顶元素的平均数是中位数 return (large.peek() + small.peek()) / 2.0; } public void addNum(int num) { if (small.size() >= large.size()) { small.offer(num); large.offer(small.poll()); } else { large.offer(num); small.offer(large.poll()); } } } 添加元素，假设向large中插入元素： 如果插入的num小于small的堆顶元素，那么num就会留在small堆里，为了保证两个堆的元素数量之差不大于 1，作为交换，把small堆顶部的元素再插到large堆里。 如果插入的num大于small的堆顶元素，那么num就会成为samll的堆顶元素，最后还是会被插入large堆中。 反之，向small中插入元素是一个道理，朋友圈时间线 LeetCode 上第 335 道题 刚加到女神的微信，然后我去刷新一下我的朋友圈动态，那么女神的动态就会出现在我的动态列表，而且会和其他动态按时间排好序。 就是搞个大根堆，然后合并k个有序链表。public List getNewsFeed(int userId) { List res = new ArrayList<>(); if (!userMap.containsKey(userId)) return res; // 关注列表的⽤户 Id Set users = userMap.get(userId).followed; // ⾃动通过 time 属性从⼤到⼩排序，容量为 users 的⼤⼩ PriorityQueue pq = new PriorityQueue<>(users.size(), (a, b)->(b.time - a.time)); // 先将所有链表头节点插⼊优先级队列 for (int id : users) { Tweet twt = userMap.get(id).head; if (twt == null) continue; pq.add(twt); } while (!pq.isEmpty()) { // 最多返回 10 条就够了 if (res.size() == 10) break; // 弹出 time 值最⼤的（最近发表的） Tweet twt = pq.poll(); res.add(twt.id); // 将下⼀篇 Tweet 插⼊进⾏排序 if (twt.next != null) pq.add(twt.next); } return res; } 单调栈 下一个更大元素 I 力扣第 496 题：从后面找比当前索引指向的元素更大的元素 O(n)：总共有n个元素，每个元素都被push入栈了一次，而最多会被pop一次，没有任何冗余操作。所以总的计算规模是和元素规模n成正比的。vector nextGreaterElement(vector& nums) { vector res(nums.size()); // 存放答案的数组 stack s; // 倒着往栈里放 for (int i = nums.size() - 1; i >= 0; i--) { // 判定个子高矮 while (!s.empty() && s.top() 更暖和的气温 力扣第 1118 题：从后面找比当前索引指向的元素更大的元素vector dailyTemperatures(vector& T) { vector res(T.size()); // 这里放元素索引，而不是元素 stack s; /* 单调栈模板 */ for (int i = T.size() - 1; i >= 0; i--) { while (!s.empty() && T[s.top()] 下一个更大元素 II 如果是循环数组，常用套路就是将数组长度翻倍： vector nextGreaterElements(vector& nums) { int n = nums.size(); vector res(n); stack s; // 假装这个数组长度翻倍了 for (int i = 2 * n - 1; i >= 0; i--) { // 索引要求模，其他的和模板一样 while (!s.empty() && s.top() 单调队列 滑动窗口最大值 力扣第 239 题 push操作中含有 while 循环，复杂度确实不是O(1)，但是算法整体的复杂度依然是O(N)线性时间。要这样想，nums中的每个元素最多被push_back和pop_back一次，没有任何多余操作，所以整体的复杂度还是O(N) /* 单调队列的实现 */ class MonotonicQueue { LinkedList q = new LinkedList<>(); public void push(int n) { // 将小于 n 的元素全部删除 while (!q.isEmpty() && q.getLast() res = new ArrayList<>(); for (int i = 0; i 栈实现队列 class MyQueue { private Stack s1, s2; public MyQueue() { s1 = new Stack<>(); s2 = new Stack<>(); } /** 添加元素到队尾 */ public void push(int x) { s1.push(x); } /** 返回队头元素 */ public int peek() { if (s2.isEmpty()) // 把 s1 元素压入 s2 while (!s1.isEmpty()) s2.push(s1.pop()); return s2.peek(); } /** 删除队头的元素并返回 */ public int pop() { // 先调用 peek 保证 s2 非空 peek(); return s2.pop(); } /** 判断队列是否为空 */ public Boolean empty() { return s1.isEmpty() && s2.isEmpty(); } } 队列实现栈 class MyStack { Queue q = new LinkedList<>(); int top_elem = 0; /** 添加元素到栈顶 */ public void push(int x) { // x 是队列的队尾，是栈的栈顶 q.offer(x); top_elem = x; } /** 返回栈顶元素 */ public int top() { return top_elem; } /** 删除栈顶的元素并返回 */ public int pop() { int size = q.size(); // 留下队尾 2 个元素 while (size > 2) { q.offer(q.poll()); size--; } // 记录新的队尾元素 top_elem = q.peek(); q.offer(q.poll()); // 删除之前的队尾元素 return q.poll(); } /** 判断栈是否为空 */ public Boolean empty() { return q.isEmpty(); } } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-17 19:30:35 "},"chapter1/section10/":{"url":"chapter1/section10/","title":"二分搜索","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 吃香蕉 运送货物 分割数组的最大值 二分搜索 吃香蕉 力扣第 875 题 // 定义：速度为 x 时，需要 f(x) 小时吃完所有香蕉 // f(x) 随着 x 的增加单调递减 int f(int[] piles, int x) { int hours = 0; for (int i = 0; i 0) { hours++; } } return hours; } public int minEatingSpeed(int[] piles, int H) { int left = 1; //题目说了1 H) { // 需要让 f(x) 的返回值小一些 left = mid + 1; } } return left; } 运送货物 力扣第 1011 题 // 定义：当运载能力为 x 时，需要 f(x) 天运完所有货物 // f(x) 随着 x 的增加单调递减 int f(int[] weights, int x) { int days = 0; for (int i = 0; i days) { // 需要让 f(x) 的返回值小一些 left = mid + 1; } } return left; } 分割数组的最大值 力扣第 410 题 ①回溯暴力穷举可以在哪几个地方进行分割的组合个数，根据穷举结果去计算每种方案的最大子数组和。 ② /* 辅助函数，若限制最大子数组和为 max， 计算 nums 至少可以被分割成几个子数组 */ int split(int[] nums, int max) { // 至少可以分割的子数组数量 int count = 1; // 记录每个子数组的元素和 int sum = 0; for (int i = 0; i max) { // 如果当前子数组和大于 max 限制 // 则这个子数组不能再添加元素了 count++; sum = nums[i]; } else { // 当前子数组和还没达到 max 限制 // 还可以添加元素 sum += nums[i]; } } return count; } int splitArray(int[] nums, int m) { // 一般搜索区间是左开右闭的，所以 hi 要额外加一 //最大子数组和max的取值范围显然是，子数组至少包含一个元素，或至多包含整个数组， int lo = getMax(nums), hi = getSum(nums) + 1; while (lo m) { // 最大子数组和上限低了，增加一些 lo = mid + 1; } } return lo; } int getMax(int[] nums) {/* 计算数组中的最大值 */} int getSum(int[] nums) {/* 计算数组元素和 */} Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-06 10:22:46 "},"chapter1/section11/":{"url":"chapter1/section11/","title":"随机","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 实现O(1)随机集合 避开黑名单的随机数 随机 实现O(1)随机集合 增、删、随机获得一个值，都是O(1) class RandomizedSet { public: // 存储元素的值 vector nums; // 记录每个元素对应在 nums 中的索引 unordered_map valToIndex; bool insert(int val) { // 若 val 已存在，不用再插入 if (valToIndex.count(val)) { return false; } // 若 val 不存在，插入到 nums 尾部， // 并记录 val 对应的索引值 valToIndex[val] = nums.size(); nums.push_back(val); return true; } bool remove(int val) { // 若 val 不存在，不用再删除 if (!valToIndex.count(val)) { return false; } // 先拿到 val 的索引 int index = valToIndex[val]; // 将最后一个元素对应的索引修改为 index valToIndex[nums.back()] = index; // 交换 val 和最后一个元素 swap(nums[index], nums.back()); // 在数组中删除元素 val nums.pop_back(); // 删除元素 val 对应的索引 valToIndex.erase(val); return true; } int getRandom() { // 随机获取 nums 中的一个元素 return nums[rand() % nums.size()]; } }; 避开黑名单的随机数 将黑名单的索引映射到白名单中，这样就算获得了黑名单的索引，其实引用的是白名单的。 class Solution { public: int sz; unordered_map mapping; Solution(int N, vector& blacklist) { sz = N - blacklist.size(); for (int b : blacklist) { mapping[b] = 666; } int last = N - 1; for (int b : blacklist) { // 如果 b 已经在区间 [sz, N) // 可以直接忽略 if (b >= sz) { continue; } //防止映射过后的索引还是黑名单的索引， //必须将黑名单的索引映射到白名单的索引 while (mapping.count(last)) { last--; } mapping[b] = last; last--; } } int pick() { // 随机选取一个索引 int index = rand() % sz; // 这个索引命中了黑名单， // 需要被映射到其他位置 if (mapping.count(index)) { return mapping[index]; } // 若没命中黑名单，则直接返回 return index; } }; Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-06 10:24:15 "},"chapter1/section12/":{"url":"chapter1/section12/","title":"去重","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 有序数组去重（快慢指针） 有序链表去重（快慢指针） 去除重复字母 去重 有序数组去重（快慢指针） 力扣第26 找到重复的，跳 int removeDuplicates(int[] nums) { int n = nums.length; if (n == 0) return 0; int slow = 0, fast = 1; while (fast 有序链表去重（快慢指针） 力扣第83 ListNode deleteDuplicates(ListNode head) { if (head == null) return null; ListNode slow = head, fast = head.next; while (fast != null) { if (fast.val != slow.val) { // nums[slow]= nums[fast]; slow.next = fast; // slow++； slow = slow.next; } // fast++ fast = fast.next; } //断开与后面重复元素的连接 slow.next = null; return head; } 去除重复字母 力扣第 316 题、第 1081 题 字典序最小的作为最终结果：比如说输入字符串s = \"babc\"，去重且符合相对位置的字符串有两个，分别是\"bac\"和\"abc\"，但是我们的算法得返回\"abc\"，因为它的字典序更小。 String removeDuplicateLetters(String s) { Stack stk = new Stack<>(); // 维护一个计数器记录字符串中字符的数量 // 因为输入为 ASCII 字符，大小 256 够用了 int[] count = new int[256]; for (int i = 0; i c) { // 若之后不存在栈顶元素了，则停止 pop if (count[stk.peek()] == 0) { break; } // 若之后还有，则可以 pop inStack[stk.pop()] = false; } stk.push(c); inStack[c] = true; } StringBuilder sb = new StringBuilder(); while (!stk.empty()) { sb.append(stk.pop()); } //反转一次才是最终结果 return sb.reverse().toString(); } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-06 10:24:14 "},"chapter1/section13/":{"url":"chapter1/section13/","title":"双指针技巧","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 移除元素（快慢指针） 移动0（快慢指针） 双指针技巧 移除元素（快慢指针） 力扣第27 找到target，跳 int removeElement(int[] nums, int val) { int fast = 0, slow = 0; while (fast 移动0（快慢指针） void moveZeroes(int[] nums) { // 去除 nums 中的所有 0 // 返回去除 0 之后的数组长度 int p = removeElement(nums, 0); // 将 p 之后的所有元素赋值为 0 for (; p Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-06 10:24:13 "},"chapter1/section14/":{"url":"chapter1/section14/","title":"其它技巧","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 最长回文子串 前缀和数组 差分数组 2Sum 田忌赛马 其它技巧 最长回文子串 少有的动态规划非最优解法的问题。 String longestPalindrome(String s) { String res; for (int i = 0; i s1.size() ? res : s1; res = res.size() > s2.size() ? res : s2; } return res; } 前缀和数组 如何快速得到某个⼦数组的和，主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。 int subarraySum(int[] nums, int k) { int n = nums.length; // map：前缀和 -> 该前缀和出现的次数 HashMap preSum = new HashMap<>(); // base case preSum.put(0, 1); int ans = 0, sum0_i = 0; for (int i = 0; i 差分数组 主要适用场景是频繁对原始数组的某个区间的元素进行增减。 比如说，我给你输入一个数组nums，然后又要求给区间nums[2..6]全部加 1，再给nums[3..9]全部减 3，再给nums[0..4]全部加 2，再给… 一通操作猛如虎，然后问你，最后nums数组的值是什么？ 构造一个diff差分数组：diff[i]=nums[i]-nums[i-1]： diff差分数组反推原始数组nums：nums[i]=nums[i-1]+diff[i]。 int[] nums = new int[diff.length]; // 根据差分数组反推结果数组 nums[0] = diff[0]; for (int i = 1; i 如果你想对区间nums[i..j]的元素全部加 3，那么只需要让diff[i] += 3，然后再让diff[j+1] -= 3即可： diff[i] += val; if (j + 1 【力扣第 1109 题】「航班预订统计」 int[] corpFlightBookings(int[][] bookings, int n) { // nums 初始化为全 0 int[] nums = new int[n]; // 构造差分解法 Difference df = new Difference(nums); for (int[] booking : bookings) { // 注意转成数组索引要减一哦 int i = booking[0] - 1; int j = booking[1] - 1; int val = booking[2]; // 对区间 nums[i..j] 增加 val df.increment(i, j, val); } // 返回最终的结果数组 return df.result(); } 2Sum vector> twoSumTarget(vector& nums, int target) { // nums 数组必须有序 sort(nums.begin(), nums.end()); int lo = 0, hi = nums.size() - 1; vector> res; while (lo target) { while (lo 田忌赛马 \\870. 优势洗牌 打得过就打，打不过就拿自己的垃圾和对方的精锐互换。 根据这个思路，我们需要对两个数组排序，但是nums2中元素的顺序不能改变，因为计算结果的顺序依赖nums2的顺序，所以不能直接对nums2进行排序，而是利用其他数据结构来辅助。 int[] advantageCount(int[] nums1, int[] nums2) { int n = nums1.length; // 给 nums2 降序排序 PriorityQueue maxpq = new PriorityQueue<>( (int[] pair1, int[] pair2) -> { return pair2[1] - pair1[1]; }); for (int i = 0; i Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-06 19:13:52 "},"chapter1/section15/":{"url":"chapter1/section15/","title":"数学","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 丑数 统计质数 数学 丑数 https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=117 int GetUglyNumber_Solution(int idx) { int i=0,j=0,k=0,now;//i,j,k分别为指向下一个*2,*3,*5可能成为下一个丑数的数的位置的指针 vector v(1,1);//放入1个1 while(v.size()统计质数 https://blog.csdn.net/suoxd123/article/details/104116131 统计所有小于非负整数 n 的质数的数量。 解法一（检测） 详情查看链接 解法二（赋值） public class Solution { public int CountPrimes(int n) { bool [] r = new bool[n]; for(int i=0;i Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-06 10:25:09 "},"chapter2/section1/":{"url":"chapter2/section1/","title":"链表","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1. 反转链表 2. 链表内指定区间反转 3. 链表中的节点每k个一组翻转 4. 合并两个排序的链表 5. 合并k个已排序的链表 6. 判断链表中是否有环 7. 链表中环的入口结点 8. 链表中倒数最后k个结点 9. 删除链表的倒数第n个节点 10. 两个链表的第一个公共结点 11. 链表相加(二) 12. 单链表的排序 13. 判断一个链表是否为回文结构 14. 链表的奇偶重排 15. 删除有序链表中重复的元素-I 16. 删除有序链表中重复的元素-II 链表 1. 反转链表 /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { public ListNode ReverseList(ListNode head) { if(head == null || head.next == null) return head; ListNode next = head.next; ListNode reverse = ReverseList(next); next.next = head; head.next = null; return reverse; } } 2. 链表内指定区间反转 import java.util.*; /* * public class ListNode { * int val; * ListNode next = null; * } */ public class Solution { /** * * @param head ListNode类 * @param m int整型 * @param n int整型 * @return ListNode类 */ public ListNode reverseBetween (ListNode head, int m, int n) { // write code here ListNode dummy = new ListNode(-1); dummy.next = head; ListNode pre = dummy; for(int i = 0; i 3. 链表中的节点每k个一组翻转 import java.util.*; /* * public class ListNode { * int val; * ListNode next = null; * } */ public class Solution { /** * * @param head ListNode类 * @param k int整型 * @return ListNode类 */ public ListNode reverseKGroup (ListNode head, int k) { // write code here ListNode node = head; for(int i = 0; i 4. 合并两个排序的链表 /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { public ListNode Merge(ListNode list1,ListNode list2) { ListNode dummy = new ListNode(-1); ListNode cur = dummy; while(list1 != null && list2 != null){ if(list1.val 5. 合并k个已排序的链表 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ import java.util.*; public class Solution { public ListNode mergeKLists(ArrayList lists) { if(lists.size() == 0) return null; PriorityQueue minHeap = new PriorityQueue<>(lists.size(),(a,b)->{ return a.val-b.val; }); for(ListNode node : lists){ if(node != null) minHeap.add(node); } return merge(minHeap); } public ListNode merge(PriorityQueue queue){ if(queue.isEmpty()) return null; ListNode node = queue.poll(); if(node.next!=null) queue.add(node.next); node.next = merge(queue); return node; } } 6. 判断链表中是否有环 /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public boolean hasCycle(ListNode head) { if(head == null) return false; ListNode slow = head, fast = head; while(slow != null && fast != null){ slow = slow.next; if(fast.next != null){ fast = fast.next.next; }else return false; if(slow == fast) return true; } return false; } } 7. 链表中环的入口结点 /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } } */ public class Solution { public ListNode EntryNodeOfLoop(ListNode pHead) { if(pHead == null) return pHead; ListNode meetPoint = findMeet(pHead); if(meetPoint == null) return null; ListNode one = pHead, two = meetPoint; if(one == two) return one; while(one != null && two != null){ one = one.next; two = two.next; if(one == two) return one; } return null; } private ListNode findMeet(ListNode head){ ListNode slow = head, fast = head; while(slow != null && fast != null){ slow = slow.next; if(fast.next != null){ fast = fast.next.next; } if(fast == null) return null; if(fast == slow) return slow; } return null; } } 8. 链表中倒数最后k个结点 import java.util.*; /* * public class ListNode { * int val; * ListNode next = null; * public ListNode(int val) { * this.val = val; * } * } */ public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param pHead ListNode类 * @param k int整型 * @return ListNode类 */ public ListNode FindKthToTail (ListNode pHead, int k) { // write code here ListNode slow = pHead, fast = pHead; int step = 0; while(fast != null){ fast = fast.next; if(step >= k) { slow = slow.next; } step++; } if(step 9. 删除链表的倒数第n个节点 import java.util.*; /* * public class ListNode { * int val; * ListNode next = null; * } */ public class Solution { /** * * @param head ListNode类 * @param n int整型 * @return ListNode类 */ public ListNode removeNthFromEnd (ListNode head, int n) { // write code here if(n==0){ return head; } ListNode tail = head; ListNode predict = head; for (int i = 0; i 10. 两个链表的第一个公共结点 /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) { if(pHead1 == null || pHead2 == null) return null; ListNode cur1 = pHead1, cur2 = pHead2; while(cur1 != cur2){ if(cur1 == null) cur1 = pHead2; else cur1 = cur1.next; if(cur2 == null) cur2 = pHead1; else cur2 = cur2.next; } return cur1; } } 11. 链表相加(二) import java.util.*; /* * public class ListNode { * int val; * ListNode next = null; * } */ public class Solution { /** * * @param head1 ListNode类 * @param head2 ListNode类 * @return ListNode类 */ public ListNode addInList (ListNode head1, ListNode head2) { // 进行判空处理 if(head1 == null) return head2; if(head2 == null){ return head1; } // 反转h1链表 head1 = reverse(head1); // 反转h2链表 head2 = reverse(head2); // 创建新的链表头节点 ListNode head = new ListNode(-1); ListNode nHead = head; // 记录进位的数值 int tmp = 0; while(head1 != null || head2 != null){ // val用来累加此时的数值（加数+加数+上一位的进位=当前总的数值） int val = tmp; // 当节点不为空的时候，则需要加上当前节点的值 if (head1 != null) { val += head1.val; head1 = head1.next; } // 当节点不为空的时候，则需要加上当前节点的值 if (head2 != null) { val += head2.val; head2 = head2.next; } // 求出进位 tmp = val/10; // 进位后剩下的数值即为当前节点的数值 nHead.next = new ListNode(val%10); // 下一个节点 nHead = nHead.next; } // 最后当两条链表都加完的时候，进位不为0的时候，则需要再加上这个进位 if(tmp > 0){ nHead.next = new ListNode(tmp); } // 重新反转回来返回 return reverse(head.next); } // 反转链表 ListNode reverse(ListNode head){ if(head == null) return head; ListNode cur = head; ListNode node = null; while(cur != null){ ListNode tail = cur.next; cur.next = node; node = cur; cur = tail; } return node; } } 12. 单链表的排序 import java.util.*; /* * public class ListNode { * int val; * ListNode next = null; * } */ public class Solution { /** * * @param head ListNode类 the head node * @return ListNode类 */ public ListNode sortInList (ListNode head) { // write code here if(head == null || head.next == null){ return head; } ListNode slow = head, fast = head.next; while(fast != null && fast.next != null){ slow = slow.next; fast = fast.next.next; } ListNode newList = slow.next; slow.next = null; ListNode left = sortInList(head); ListNode right = sortInList(newList); ListNode res = new ListNode(-1); ListNode cur = res; while(left != null && right != null){ if(left.val 13. 判断一个链表是否为回文结构 import java.util.*; /* * public class ListNode { * int val; * ListNode next = null; * } */ public class Solution { /** * * @param head ListNode类 the head * @return bool布尔型 */ ListNode left; public boolean isPail (ListNode head) { // write code here left = head; return traverse(head); } private boolean traverse(ListNode right){ if(right == null) return true; boolean flag = traverse(right.next); boolean res = flag && left.val == right.val; left = left.next; return res; } } 14. 链表的奇偶重排 import java.util.*; /* * public class ListNode { * int val; * ListNode next = null; * public ListNode(int val) { * this.val = val; * } * } */ public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param head ListNode类 * @return ListNode类 */ public ListNode oddEvenList (ListNode head) { // write code here if(head == null) return null; ListNode odd = head; ListNode even = head.next; ListNode evenHead = even; while(even != null && even.next != null){ odd.next = odd.next.next; even.next = even.next.next; odd = odd.next; even = even.next; } odd.next = evenHead; return head; } } 15. 删除有序链表中重复的元素-I import java.util.*; /* * public class ListNode { * int val; * ListNode next = null; * } */ public class Solution { /** * * @param head ListNode类 * @return ListNode类 */ public ListNode deleteDuplicates (ListNode head) { // write code here if(head == null) return null; ListNode slow = head, fast = head.next; while(fast != null){ if(slow.val != fast.val){ slow.next = fast; slow = slow.next; } fast = fast.next; } slow.next = null; return head; } } 16. 删除有序链表中重复的元素-II import java.util.*; /* * public class ListNode { * int val; * ListNode next = null; * } */ public class Solution { /** * * @param head ListNode类 * @return ListNode类 */ public ListNode deleteDuplicates (ListNode head) { // write code here if(head == null) return null; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode pre = dummy; while(head != null && head.next != null){ if(head.val != head.next.val){ pre = head; head = head.next; }else{ int repeatVal = head.val; head = head.next; while(head != null && head.val == repeatVal){ head = head.next; } pre.next = head; } } return dummy.next; } } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-17 20:02:29 "},"chapter2/section2/":{"url":"chapter2/section2/","title":"二分查找/排序","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 17. 二分查找-I 18. 二维数组中的查找 19. 寻找峰值 20. 数组中的逆序对 21. 旋转数组的最小数字 22. 比较版本号 二分查找/排序 17. 二分查找-I import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param nums int整型一维数组 * @param target int整型 * @return int整型 */ public int search (int[] nums, int target) { // write code here int left = 0, right = nums.length - 1; while(left nums[mid]){ left = mid + 1; }else{ right = mid - 1; } } if(left >= nums.length || nums[left] != target) return -1; return left; } } 18. 二维数组中的查找 public class Solution { public boolean Find(int target, int [][] array) { if(array.length == 0) return false; int r = array.length; //行 int l = array[0].length; //列 int left = 0, down = r - 1; while(left=0) { int tmp = array[down][left]; if( tmp == target) return true; else if(tmp 19. 寻找峰值 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param nums int整型一维数组 * @return int整型 */ public int findPeakElement(int[] nums){ int left = 0, right = nums.length - 1; while (left 0){ return mid; } if(compareNeighbor(nums,mid-1,mid) b[0] ? 1 : -1; //正常对比 if(a[1] == b[1]) return 0; return a[1] > b[1] ? 1 : -1; } } 20. 数组中的逆序对 归并典型用法 public class Solution { private int count; public int InversePairs(int [] array) { if(array.length != 0){ divide(array,0,array.length - 1); } return count; } private void divide(int[] array, int start, int end){ if(start >= end) return; int mid = start + (end - start) / 2; divide(array,start,mid); divide(array,mid+1,end); merge(array,start,mid,end); } private void merge(int[] array, int start, int mid, int end){ int[] res = new int[end-start+1]; int i = start, j = mid + 1, k = 0; while(i 21. 旋转数组的最小数字 import java.util.ArrayList; public class Solution { public int minNumberInRotateArray(int [] nums) { int left = 0, right = nums.length - 1; while(left nums[right]){ left = mid + 1; }else { right--; } } return nums[left]; } } 22. 比较版本号 import java.util.*; import java.math.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * 比较版本号 * @param version1 string字符串 * @param version2 string字符串 * @return int整型 */ public int compare (String version1, String version2) { // write code here String[] s1 = version1.split(\"\\\\.\"); String[] s2 = version2.split(\"\\\\.\"); int n = Math.max(s1.length, s2.length); for (int i = 0; i 0) return 1; else if (c1.compareTo(c2) Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-17 20:05:03 "},"chapter2/section3/":{"url":"chapter2/section3/","title":"二叉树","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 23. 二叉树的前序遍历 24. 二叉树的中序遍历 25. 二叉树的后序遍历 26. 求二叉树的层序遍历 27. 按之字形顺序打印二叉树 28. 二叉树的最大深度 29. 二叉树中和为某一值的路径(一) 30. 二叉搜索树与双向链表 31. 对称的二叉树 32. 合并二叉树 33. 二叉树的镜像 34. 判断是不是二叉搜索树 35. 判断是不是完全二叉树 36. 判断是不是平衡二叉树 37. 二叉搜索树的最近公共祖先 38. 在二叉树中找到两个节点的最近公共祖先 39. 序列化二叉树 40. 重建二叉树 41. 输出二叉树的右视图 二叉树 23. 二叉树的前序遍历 import java.util.*; /* * public class TreeNode { * int val = 0; * TreeNode left = null; * TreeNode right = null; * public TreeNode(int val) { * this.val = val; * } * } */ public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param root TreeNode类 * @return int整型一维数组 */ public int[] preorderTraversal (TreeNode root) { // write code here List res = new ArrayList<>(); preOrder(root,res); int[] resArray = new int[res.size()]; int j = 0; for(Integer i : res) resArray[j++] = i; return resArray; } private void preOrder(TreeNode root, List res){ if(root == null) return; res.add(root.val); preOrder(root.left,res); preOrder(root.right,res); } } 24. 二叉树的中序遍历 import java.util.*; /* * public class TreeNode { * int val = 0; * TreeNode left = null; * TreeNode right = null; * public TreeNode(int val) { * this.val = val; * } * } */ public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param root TreeNode类 * @return int整型一维数组 */ public int[] inorderTraversal (TreeNode root) { // write code here List res = new ArrayList<>(); preOrder(root,res); int[] resArray = new int[res.size()]; int j = 0; for(Integer i : res) resArray[j++] = i; return resArray; } private void preOrder(TreeNode root, List res){ if(root == null) return; preOrder(root.left,res); res.add(root.val); preOrder(root.right,res); } } 25. 二叉树的后序遍历 import java.util.*; /* * public class TreeNode { * int val = 0; * TreeNode left = null; * TreeNode right = null; * public TreeNode(int val) { * this.val = val; * } * } */ public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param root TreeNode类 * @return int整型一维数组 */ public int[] postorderTraversal (TreeNode root) { List res = new ArrayList<>(); preOrder(root,res); int[] resArray = new int[res.size()]; int j = 0; for(Integer i : res) resArray[j++] = i; return resArray; } private void preOrder(TreeNode root, List res){ if(root == null) return; preOrder(root.left,res); preOrder(root.right,res); res.add(root.val); } } 26. 求二叉树的层序遍历 import java.util.*; /* * public class TreeNode { * int val = 0; * TreeNode left = null; * TreeNode right = null; * } */ public class Solution { /** * * @param root TreeNode类 * @return int整型ArrayList> */ public ArrayList> levelOrder (TreeNode root) { // write code here if(root == null) return new ArrayList<>(0); ArrayList> res = new ArrayList<>(); Queue q = new LinkedList<>(); q.offer(root); while(!q.isEmpty()){ ArrayList levelList = new ArrayList<>(); int len = q.size(); for(int i = 0; i 27. 按之字形顺序打印二叉树 import java.util.*; /* public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public ArrayList > Print(TreeNode root) { if(root == null) return new ArrayList<>(0); ArrayList> res = new ArrayList<>(); Queue q = new LinkedList<>(); q.offer(root); boolean odd = true; while(!q.isEmpty()){ ArrayList levelList = new ArrayList<>(); int len = q.size(); Deque nextQueue = new LinkedList<>(); for(int i = 0; i 28. 二叉树的最大深度 import java.util.*; /* * public class TreeNode { * int val = 0; * TreeNode left = null; * TreeNode right = null; * } */ public class Solution { /** * * @param root TreeNode类 * @return int整型 */ public int maxDepth (TreeNode root) { // write code here if(root == null) return 0; Queue q = new LinkedList<>(); q.offer(root); int level = 0; while(!q.isEmpty()){ int len = q.size(); for(int i = 0; i 29. 二叉树中和为某一值的路径(一) import java.util.*; /* * public class TreeNode { * int val = 0; * TreeNode left = null; * TreeNode right = null; * } */ public class Solution { /** * * @param root TreeNode类 * @param sum int整型 * @return bool布尔型 */ public boolean hasPathSum (TreeNode root, int sum) { // write code here if(root == null) return false; sum -= root.val; if(0 == sum && root.left == null && root.right == null) return true; return hasPathSum(root.left,sum) || hasPathSum(root.right,sum); } } 30. 二叉搜索树与双向链表 /** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { TreeNode head = null; TreeNode pre =null; public TreeNode Convert(TreeNode pRootOfTree) { process(pRootOfTree); return head; } public void process(TreeNode root) { if (root == null) { return; } process(root.left); if(head==null)head=root; else{ root.left=pre; pre.right=root; } pre=root; process(root.right); } } 31. 对称的二叉树 /* public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { boolean isSymmetrical(TreeNode pRoot) { if(pRoot==null)return true; return calcRoot(pRoot.left,pRoot.right); } boolean calcRoot(TreeNode left, TreeNode right){ if(left==null && right==null) return true; if(left==null && right != null || left!=null && right==null) return false; if(left.val != right.val) return false; return calcRoot(left.right,right.left) && calcRoot(left.left,right.right); } } 32. 合并二叉树 import java.util.*; /* * public class TreeNode { * int val = 0; * TreeNode left = null; * TreeNode right = null; * } */ public class Solution { /** * * @param t1 TreeNode类 * @param t2 TreeNode类 * @return TreeNode类 */ public TreeNode mergeTrees (TreeNode t1, TreeNode t2) { if(t1==null) return t2; if(t2==null) return t1; TreeNode root=new TreeNode(t1.val+t2.val); root.left=mergeTrees(t1.left,t2.left); root.right=mergeTrees(t1.right,t2.right); return root; } } 33. 二叉树的镜像 import java.util.*; /* * public class TreeNode { * int val = 0; * TreeNode left = null; * TreeNode right = null; * public TreeNode(int val) { * this.val = val; * } * } */ public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param pRoot TreeNode类 * @return TreeNode类 */ public TreeNode Mirror (TreeNode pRoot) { // write code here if(pRoot == null) return null; TreeNode tmp = pRoot.left; pRoot.left = pRoot.right; pRoot.right = tmp; Mirror(pRoot.right); Mirror(pRoot.left); return pRoot; } } 34. 判断是不是二叉搜索树 import java.util.*; /* * public class TreeNode { * int val = 0; * TreeNode left = null; * TreeNode right = null; * public TreeNode(int val) { * this.val = val; * } * } */ public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param root TreeNode类 * @return bool布尔型 */ int min = Integer.MIN_VALUE; public boolean isValidBST (TreeNode root) { // write code here return dfs(root,Integer.MIN_VALUE,Integer.MAX_VALUE); } boolean dfs(TreeNode root,int l,int r){ if(root==null){ return true; } // 如果当前节点的值小于左区间或者大于右区间，则返回false if(root.valr){ return false; } //递归左儿子，并将左儿子的右区间修改为父节点的值 //递归右儿子，并将右儿子的左区间修改为父节点的值 return dfs(root.left,l,root.val) && dfs(root.right,root.val,r); } } 35. 判断是不是完全二叉树 import java.util.*; /* * public class TreeNode { * int val = 0; * TreeNode left = null; * TreeNode right = null; * public TreeNode(int val) { * this.val = val; * } * } */ public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param root TreeNode类 * @return bool布尔型 */ public boolean isCompleteTree (TreeNode root) { // write code here if(root == null) return true; Queue queue = new LinkedList<>(); queue.offer(root); TreeNode cur; boolean flag = false; while(!queue.isEmpty()){ cur = queue.poll(); if(cur == null){ flag = true; continue; } if(flag) return false; queue.offer(cur.left); queue.offer(cur.right); } return true; } } 36. 判断是不是平衡二叉树 public class Solution { public boolean IsBalanced_Solution(TreeNode root){ // 边界值：空树返回true if(root==null) return true; // 最大深度-最小深度=高度差, 并且从每个节点看进来， 左右子树都是平衡二叉树 return IsBalanced_Solution(root.left) && IsBalanced_Solution(root.right) && Math.abs(maxDepth(root.left)-maxDepth(root.right))37. 二叉搜索树的最近公共祖先 import java.util.*; /* * public class TreeNode { * int val = 0; * TreeNode left = null; * TreeNode right = null; * public TreeNode(int val) { * this.val = val; * } * } */ public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param root TreeNode类 * @param p int整型 * @param q int整型 * @return int整型 */ public int lowestCommonAncestor (TreeNode root, int p, int q) { // write code here if(root == null) return -1; if(root.val == p || root.val == q) return root.val; int left = lowestCommonAncestor(root.left, p, q); int right = lowestCommonAncestor(root.right, p, q); if(left != -1 && right != -1) return root.val; if(left == -1 && right == -1) return -1; return left != -1 ? left : right; } } 38. 在二叉树中找到两个节点的最近公共祖先 import java.util.*; /* * public class TreeNode { * int val = 0; * TreeNode left = null; * TreeNode right = null; * } */ public class Solution { /** * * @param root TreeNode类 * @param o1 int整型 * @param o2 int整型 * @return int整型 */ public int lowestCommonAncestor (TreeNode root, int p, int q) { // write code here if(root == null) return -1; if(root.val == p || root.val == q) return root.val; int left = lowestCommonAncestor(root.left, p, q); int right = lowestCommonAncestor(root.right, p, q); if(left != -1 && right != -1) return root.val; if(left == -1 && right == -1) return -1; return left != -1 ? left : right; } } 39. 序列化二叉树 /* public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ import java.util.*; public class Solution { String Serialize(TreeNode root) { //遇到null怎么办 if(root==null){ return \"X,\"; } String left=Serialize(root.left); String right=Serialize(root.right); return root.val+\",\"+left+right; } TreeNode Deserialize(String str) { String[] nodes=str.split(\",\"); //将String数组转换为list Deque deque=new LinkedList<>(Arrays.asList(nodes)); return buildTree(deque); } TreeNode buildTree(Deque dq){ String var=dq.poll(); //若为X，说明为空节点 if(var.equals(\"X\")){ return null; } TreeNode root=new TreeNode(Integer.parseInt(var)); root.left=buildTree(dq); root.right=buildTree(dq); return root; } } 40. 重建二叉树 import java.util.*; /** * Definition for binary tree * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ public class Solution { public int preindex = 0; public TreeNode reConstructBinaryTreeCore(int[] pre,int[] vin,int inbegin,int inend){ if(inbegin > inend){ return null; } TreeNode root = new TreeNode(pre[preindex]); int rootindex = findRoot(vin,inbegin,inend,pre[preindex]); preindex++; root.left = reConstructBinaryTreeCore(pre,vin,inbegin,rootindex - 1); root.right = reConstructBinaryTreeCore(pre,vin,rootindex + 1,inend); return root; } public int findRoot(int[] vin,int start,int end,int key){ if(start > end){ return -1; } for(int i = start;i 41. 输出二叉树的右视图 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * 求二叉树的右视图 * @param xianxu int整型一维数组 先序遍历 * @param zhongxu int整型一维数组 中序遍历 * @return int整型一维数组 */ public int[] solve (int[] xianxu, int[] zhongxu) { List res = new ArrayList<>(); //先确定二叉树 TreeNode root = reconstrution(xianxu, 0, xianxu.length - 1, zhongxu, 0, zhongxu.length - 1); //使用队列，对树进行层次遍历 Queue queue = new LinkedList<>(); queue.offer(root); while(!queue.isEmpty()) { int size = queue.size(); for(int i = 0; i x).toArray(); } //递归，类似回溯：路径、选择列表、结束条件 //但是回溯要移除选择，而递归无需移除选择 public TreeNode reconstrution(int[] xianxu, int preStart, int preEnd, int[] zhongxu, int inStart, int inEnd) { if(preStart > preEnd || inStart > inEnd) { return null; } TreeNode root = new TreeNode(xianxu[preStart]); //找到中序的位置 int i = 0; for(i = inStart; i Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-17 20:12:37 "},"chapter2/section4/":{"url":"chapter2/section4/","title":"堆/栈/队列","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 42. 用两个栈实现队列 43. 包含min函数的栈 44. 有效括号序列 45. 滑动窗口的最大值 46. 最小的K个数 47. 寻找第K大 48. 数据流中的中位数 49. 表达式求值 堆/栈/队列 42. 用两个栈实现队列 import java.util.Stack; public class Solution { Stack stack1 = new Stack(); Stack stack2 = new Stack(); public void push(int node) { stack1.push(node); } public int pop() { if(stack1.empty()&&stack2.empty()){ throw new RuntimeException(\"Queue is empty!\"); } if(stack2.empty()){ while(!stack1.empty()){ stack2.push(stack1.pop()); } } return stack2.pop(); } } 43. 包含min函数的栈 import java.util.Stack; public class Solution { Stack stack1 = new Stack(); Stack stack2 = new Stack(); public void push(int value) { stack1.push(value); if(stack2.empty() || value44. 有效括号序列 import java.util.*; public class Solution { /** * * @param s string字符串 * @return bool布尔型 */ public boolean isValid (String s) { // write code here char[] c=s.toCharArray(); Stack stack=new Stack<>(); for(Character cha:c){ if(cha=='(' || cha=='{' || cha=='[') { stack.push(cha); }else{ if(stack.isEmpty()) return false; Character k=stack.pop(); if(k=='(' && cha!=')' || k=='{' && cha!='}' || k=='[' && cha!=']') return false; } } return stack.isEmpty(); } } 45. 滑动窗口的最大值 import java.util.*; public class Solution { public ArrayList maxInWindows(int[] nums, int size) { ArrayList res = new ArrayList<>(); if(size == 0 || size > nums.length) return res; Deque dq = new LinkedList<>(); int i = 0; for(; i 46. 最小的K个数 import java.util.ArrayList; import java.util.*; public class Solution { public ArrayList GetLeastNumbers_Solution(int [] input, int k) { if(k==0) return new ArrayList<>(); PriorityQueue bigHeap = new PriorityQueue<>(k,(a,b)->(b-a)); int len = input.length; for(int i=0;i input[i]){ bigHeap.poll(); bigHeap.offer(input[i]); } } return new ArrayList(bigHeap); } } 47. 寻找第K大 import java.util.*; public class Solution { public int findKth(int[] a, int n, int k) { // write code here quickSort(a, 0, n-1, k); return a[k-1]; } private void quickSort(int[] a, int start, int end, int k){ if(start >= end) return ; int index = divide(a, start, end); quickSort(a, start, index-1, k); quickSort(a, index+1,end,k); } private int divide(int[] a, int start, int end){ int tmp = a[end]; while(start = tmp) start++; a[end] = a[start]; while(start 48. 数据流中的中位数 import java.util.*; public class Solution { private PriorityQueue big = new PriorityQueue<>((a,b)->{ return (int)b-a; }); private PriorityQueue small = new PriorityQueue<>(); public void Insert(Integer num) { if(big.size() > small.size()){ big.offer(num); small.offer(big.poll()); }else{ small.offer(num); big.offer(small.poll()); } } public Double GetMedian() { if(big.size() > small.size()){ return Double.parseDouble(big.peek().toString()); }else if(big.size() 49. 表达式求值 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * 返回表达式的值 * @param s string字符串 待计算的表达式 * @return int整型 */ //中缀转后缀，再求值后缀 public int solve (String s) { // write code here s.replaceAll(\" \",\"\"); Map priority = new HashMap<>(); priority.put('+',1); priority.put('-',1); priority.put('*',2); Stack numStack = new Stack<>(); Stack opStack = new Stack<>(); int len = s.length(); for(int i = 0; i = '0' && s.charAt(i) = '0' && s.charAt(i-1) Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-17 20:18:37 "},"chapter2/section5/":{"url":"chapter2/section5/","title":"哈希","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 50. 两数之和 51. 数组中出现次数超过一半的数字 52. 数组中只出现一次的两个数字 53. 缺失的第一个正整数 54. 三数之和 哈希 50. 两数之和 import java.util.*; public class Solution { /** * * @param numbers int整型一维数组 * @param target int整型 * @return int整型一维数组 */ public int[] twoSum (int[] numbers, int target) { // write code here //key为数组值，value为题目要求的下标，即数组下标+1 HashMap map = new HashMap<>(); int[] result = new int[2]; for(int i = 0;i key=target-numbers[i] if(map.containsKey(target-numbers[i])){ result[0] = map.get(target-numbers[i]); result[1] = i+1; return result; }else{ map.put(numbers[i],i+1); } } return result; } } 51. 数组中出现次数超过一半的数字 https://blog.csdn.net/qq_44688635/article/details/115638831 public class Solution { //摩尔投票法(候选法) //对拼消耗，剩下的一定是自己人 public int MoreThanHalfNum_Solution(int [] array) { int candidate = 0, votes = 0; for(int cur : array){ if(votes == 0) candidate = cur; if(candidate != cur) votes--; else votes++; } return candidate; } } 52. 数组中只出现一次的两个数字 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param array int整型一维数组 * @return int整型一维数组 */ public int[] FindNumsAppearOnce (int[] array) { // write code here int[] res = new int[2]; // 创建一个哈希表 HashSet set = new HashSet<>(); for(int i = 0; i 53. 缺失的第一个正整数 https://www.cnblogs.com/zhanghongfeng/p/11696533.html import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param nums int整型一维数组 * @return int整型 */ public int minNumberDisappeared (int[] nums) { // write code here int len = nums.length,tmp = -1; for(int i = 0; i 0 && nums[i] 54. 三数之和 import java.util.*; public class Solution { public ArrayList> threeSum(int[] num) { Arrays.sort(num); ArrayList> resList = new ArrayList<>(); int i = 0, len = num.length - 2, leftVal = -1; boolean flag = false; while(i > twoSum(int[] num, int cur, int start, int end){ int target = 0 - cur; int left = start, right = end; ArrayList> resList = new ArrayList<>(); while(left target){ while(left (Arrays.asList(res))); while(left Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-06 14:11:47 "},"chapter2/section6/":{"url":"chapter2/section6/","title":"递归/回溯","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 55. 没有重复项数字的全排列 56. 有重复项数字的全排列 57. 岛屿数量 58. 字符串的排列 59. N皇后问题 60. 括号生成 61. 矩阵最长递增路径 递归/回溯 55. 没有重复项数字的全排列 import java.util.*; public class Solution { private ArrayList> resList; private boolean[] isVisited; public ArrayList> permute(int[] num) { resList = new ArrayList<>(); isVisited = new boolean[num.length]; traverse(num,new ArrayList<>()); return resList; } private void traverse(int[] num, ArrayList res){ if(res.size() == num.length){ resList.add(new ArrayList(res)); return; } for(int i = 0; i 56. 有重复项数字的全排列 import java.util.*; public class Solution { private ArrayList> resList; private boolean[] isVisited; public ArrayList> permuteUnique(int[] num) { resList = new ArrayList<>(); isVisited = new boolean[num.length]; Arrays.sort(num); //新增 traverse(num,new ArrayList<>()); return resList; } private void traverse(int[] num, ArrayList res){ if(res.size() == num.length){ resList.add(new ArrayList(res)); return; } for(int i = 0; i 0 && !isVisited[i] && !isVisited[i-1] && num[i] == num[i-1]) continue; isVisited[i] = true; res.add(num[i]); traverse(num,res); isVisited[i] = false; res.remove(res.size()-1); //删除最后一个 } } } 57. 岛屿数量 import java.util.*; public class Solution { /** * 判断岛屿数量 * @param grid char字符型二维数组 * @return int整型 */ //上下左右 private int[][] direction = new int[][]/\\{\\{/-1,0},{1,0},{0,-1},{0,1/\\}\\}/; public int solve (char[][] grid) { // write code here int res = 0; for(int i = 0; i = grid.length || j >= grid[0].length) return; if(grid[i][j] == '0') return; grid[i][j] = '0'; for(int[] x : direction){ int ni = i + x[0]; int nj = j + x[1]; dfs(grid, ni, nj); } } } 58. 字符串的排列 import java.util.*; public class Solution { private ArrayList resList; private boolean[] isVisited; public ArrayList Permutation(String str) { char[] charArray = str.toCharArray(); Arrays.sort(charArray); resList = new ArrayList<>(); isVisited = new boolean[charArray.length]; traverse(charArray,new StringBuilder()); return resList; } private void traverse(char[] charArray, StringBuilder sb){ if(sb.length() == charArray.length){ resList.add(sb.toString()); return; } for(int i = 0; i 0 && !isVisited[i] && !isVisited[i-1] && charArray[i] == charArray[i-1]) continue; isVisited[i] = true; sb.append(charArray[i]); traverse(charArray,sb); isVisited[i] = false; sb.deleteCharAt(sb.length() - 1); //删除最后一个 } } } 59. N皇后问题 import java.util.*; public class Solution { /** * * @param n int整型 the n * @return int整型 */ private int res = 0; public int Nqueen (int n) { // write code here int[][] queen = new int[n][n]; for(int i = 0; i = 0 && j >= 0; i--, j--){ if(queen[i][j] == 1) return false; } //检查右上方 int totalCol = queen[row].length; for(int i = row - 1, j = col + 1; i >= 0 && j 60. 括号生成 import java.util.*; public class Solution { /** * * @param n int整型 * @return string字符串ArrayList */ //使用括号时，总是先左括号，后右括号， //也就是说使用过程中，左括号数量要大于右括号的使用数量 //反过来说就是未使用的左括号数量要小于右括号的未使用数量 //如果未使用的左括号的数量大于了右括号未使用数量，那就赶紧用左括号 //否则使用右括号 private ArrayList res = new ArrayList<>(); public ArrayList generateParenthesis (int n) { // write code here traverse(new StringBuilder(),n,n); return res; } private void traverse(StringBuilder sb, int left, int right){ if (left > right) return; if (left 61. 矩阵最长递增路径 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * 递增路径的最大长度 * @param matrix int整型二维数组 描述矩阵的每个数 * @return int整型 */ private int[][] direction = new int[][]/\\{\\{/-1,0},{1,0},{0,-1},{0,1/\\}\\}/; public int maxLen = 0; private boolean[][] isVisited; public int solve (int[][] matrix) { // write code here if (matrix == null || matrix.length == 0 || matrix[0].length == 0) { return 0; } int rows = matrix.length; int cols = matrix[0].length; isVisited = new boolean[rows][cols]; for (int i = 0; i = matrix.length || j = matrix[0].length || isVisited[i][j] == true || lastVal >= matrix[i][j]) return; maxLen = Math.max(maxLen, ++step); isVisited[i][j] = true; for(int[] x : direction){ int ni = i + x[0]; int nj = j + x[1]; traverse(matrix, ni, nj, matrix[i][j], step); } isVisited[i][j] = false; } } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-19 19:24:28 "},"chapter2/section7/":{"url":"chapter2/section7/","title":"动态规划","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 62. 斐波那契数列 63. 跳台阶 64. 最小花费爬楼梯 65. 最长公共子序列(二) 66. 最长公共子串 67. 不同路径的数目(一) 68. 矩阵的最小路径和 69. 把数字翻译成字符串 70. 兑换零钱(一) 71. 最长上升子序列(一) 72. 连续子数组的最大和 73. 最长回文子串 74. 数字字符串转化成IP地址 75. 编辑距离(一) 76. 正则表达式匹配 77. 最长的括号子串 78. 打家劫舍(一) 79. 打家劫舍(二) 80. 买卖股票的最好时机(一) 81. 买卖股票的最好时机(二) 82. 买卖股票的最好时机(三) 动态规划 62. 斐波那契数列 public class Solution { public int Fibonacci(int n) { if(n 63. 跳台阶 public class Solution { public int jumpFloor(int target) { if(target == 1) return 1; if(target == 2) return 2; return jumpFloor(target-1) + jumpFloor(target-2); } } 64. 最小花费爬楼梯 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param cost int整型一维数组 * @return int整型 */ //dp[i]: 第i个台阶之前花了的最小费用 public int minCostClimbingStairs (int[] cost) { // write code here int len = cost.length; int[] dp = new int[len+1]; dp[0] = 0; dp[1] = 0; for(int i = 2; i 65. 最长公共子序列(二) import java.util.*; public class Solution { /** * longest common subsequence * @param s1 string字符串 the string * @param s2 string字符串 the string * @return string字符串 */ //在子数组arr1[0..i]和子数组arr2[0..j]中，我们要求的子序列（最长公共子序列）为dp[i][j]。 public String LCS (String s1, String s2) { // write code here int n1=s1.length(),n2=s2.length(); String[][] dp=new String[s1.length()+1][s2.length()+1]; for (int i=0; i dp[i][j-1].length() ?dp[i-1][j] :dp[i][j-1]; } } } return dp[n1][n2]==\"\"?\"-1\":dp[n1][n2]; } } 66. 最长公共子串 import java.util.*; public class Solution { /** * longest common substring * @param str1 string字符串 the string * @param str2 string字符串 the string * @return string字符串 */ // dp[i][j] 表示以str1[i]结尾，str2[j]结尾的最长公共子串 public String LCS (String str1, String str2) { // write code here if (str1.length() == 0|| str2.length() == 0 || str1 == null || str2 == null) { return \"\"; } int str1len = str1.length(); int str2len = str2.length(); int[][] dp = new int[str1len + 1][str2len + 1]; //定位最长连续子串最后一个字符对应的索引 int end = 0; //记录最长公共子串的长度 int sum = 0; for (int i = 1; i 67. 不同路径的数目(一) import java.util.*; public class Solution { /** * * @param m int整型 * @param n int整型 * @return int整型 */ public int uniquePaths (int m, int n) { // write code here if(m==1 || n==1){ return 1; } return uniquePaths(m-1,n)+uniquePaths(m,n-1); } } 68. 矩阵的最小路径和 import java.util.*; public class Solution { /** * * @param matrix int整型二维数组 the matrix * @return int整型 */ public int minPathSum (int[][] matrix) { // write code here int m = matrix.length; int n = matrix[0].length; int[][] dp = new int[m][n]; dp[0][0] = matrix[0][0]; for (int i=1;i69. 把数字翻译成字符串 import java.util.*; public class Solution { /** * 解码 * @param nums string字符串 数字串 * @return int整型 */ public int solve (String nums) { // write code here // 带条件的青蛙跳台阶 // 如果n位数和n-1位的数字组合而成的2位数在10-26闭区间中，f(n)=f(n-1)+f(n-2); // 否则f(n)=f(n-1) // 注意，有几个题干没说清楚的点在此补充： // 0+个位数不能当个位数来使，比如1102只能拆成1/10/2不能拆成11/02 // 不能出现孤立0在末位的情况，比如100不能当成10/0处理，但010可以当成0/10处理 // 字符串“0”算作0种译法 if(nums.length()==0 || \"0\".equals(nums)){ return 0; } int a = 1; int b = 1; int sum = 1; for(int i=1;i=10 && value 70. 兑换零钱(一) import java.util.*; public class Solution { /** * 最少货币数 * @param arr int整型一维数组 the array * @param aim int整型 the target * @return int整型 */ public int minMoney (int[] arr, int aim) { // write code here int[] dp = new int[aim + 1]; // 记录状态数组 Arrays.fill(dp, aim + 1); dp[0] = 0; // 初始条件 for (int i = 1; i = 0) // 边界条件判断 dp[i] = Math.min(dp[i], dp[i - arr[j]] + 1); } } return dp[aim]==aim + 1 ? -1 : dp[aim]; } } 71. 最长上升子序列(一) import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * 给定数组的最长严格上升子序列的长度。 * @param arr int整型一维数组 给定的数组 * @return int整型 */ // dp[i]表示以arr[i]结尾时的最长递增子序列长度 public int LIS (int[] arr) { // write code here int n = arr.length; if(n == 0) return 0; int[] dp = new int[n]; Arrays.fill(dp, 1); int maxLen = 1; for(int i = 1; i = 0; j--){ if(arr[j] 72. 连续子数组的最大和 import java.util.*; public class Solution { //dp[i]表示以i结尾的连续子数组的最大和。 public int FindGreatestSumOfSubArray(int[] array) { int len = array.length; int[] dp = new int[len+1]; Arrays.fill(dp,1); dp[0] = 0; // 表示没有元素 int ret = array[0]; for (int i=1; i73. 最长回文子串 非动态规划 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param A string字符串 * @return int整型 */ public int getLongestPalindrome (String A) { // write code here int maxLen = Integer.MIN_VALUE; int len = A.length(); for (int i = 0; i =0 && r74. 数字字符串转化成IP地址 回溯 import java.util.*; public class Solution { /** * * @param s string字符串 * @return string字符串ArrayList */ ArrayList res = new ArrayList<>(); public ArrayList restoreIpAddresses (String s) { // write code here ArrayList path = new ArrayList<>(); backtrack(s, 0, path); return res; } public void backtrack(String str, int startIdx, List path) { //条件满足 if(path.size() == 4) { String a = path.get(0); String b = path.get(1); String c = path.get(2); String d = path.get(3); if(a.length() + b.length() + c.length() + d.length() == str.length()) { res.add(a + \".\" + b + \".\" + c + \".\" + d); } return; } //只能一次性取1~3位，且取完后的索引不能超过字符串的长度 for(int i = startIdx; i = 0 && subNum 75. 编辑距离(一) import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param str1 string字符串 * @param str2 string字符串 * @return int整型 */ //dp[i-1][j-1] # 存储 s1[0..i] 和 s2[0..j] 的最小编辑距离 public int editDistance (String s1, String s2) { // write code here int m = s1.length(), n = s2.length(); int[][] dp = new int[m + 1][n + 1]; // base case for(int i = 1; i 76. 正则表达式匹配 为了方便，使用 ss 代指 str，使用 pp 代指 pattern。 整理一下题意，对于字符串 p 而言，有三种字符： 普通字符：需要和 s 中同一位置的字符完全匹配 '.'：能够匹配 s 中同一位置的任意字符 '*'：不能够单独使用 '*'，必须和前一个字符同时搭配使用，数据保证了 '*' 能够找到前面一个字符。能够匹配 s 中同一位置字符任意次。 所以本题关键是分析当出现 a* 这种字符时，是匹配 0 个 a、还是 1 个 a、还是 2 个 a ... 本题可以使用动态规划进行求解： 状态定义：f(i,j) 代表考虑 s 中以 i 为结尾的子串和 p 中的 j 为结尾的子串是否匹配。即最终我们要求的结果为 f[n][m] 。 状态转移：也就是我们要考虑 f(i,j) 如何求得，前面说到了 p 有三种字符，所以这里的状态转移也要分三种情况讨论： p[j] 为普通字符：匹配的条件是前面的字符匹配，同时 s 中的第 i 个字符和 p 中的第 j 位相同。 即 f(i,j) = f(i - 1, j - 1) && s[i] == p[j] 。 p[j] 为 '.'：匹配的条件是前面的字符匹配， s 中的第 i 个字符可以是任意字符。即 f(i,j) = f(i - 1, j - 1) && p[j] == '.'。 p[j] 为 '*'：读得 p[j - 1] 的字符，例如为字符 a。 然后根据 a* 实际匹配 s 中 a 的个数是 0 个、1 个、2 个 ... 3.1. 当匹配为 0 个：f(i,j) = f(i, j - 2) 3.2. 当匹配为 1 个：f(i,j) = f(i - 1, j - 2) && (s[i] == p[j - 1] || p[j - 1] == '.') 3.3. 当匹配为 2 个：f(i,j) = f(i - 2, j - 2) && ((s[i] == p[j - 1] && s[i - 1] == p[j - 1]) || p[j-1] == '.') ... 我们知道，通过「枚举」来确定 * 到底匹配多少个 a 这样的做法，算法复杂度是很高的。 我们需要挖掘一些「性质」来简化这个过程。 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param str string字符串 * @param pattern string字符串 * @return bool布尔型 */ public boolean match (String ss, String pp) { // write code here // 技巧：往原字符头部插入空格，这样得到 char 数组是从 1 开始， int n = ss.length(), m = pp.length(); ss = \" \" + ss; pp = \" \" + pp; char[] s = ss.toCharArray(); char[] p = pp.toCharArray(); // f(i,j) 代表考虑 s 中的 1~i 字符和 p 中的 1~j 字符 是否匹配 boolean[][] f = new boolean[n + 1][m + 1]; // 而且可以使得 f[0][0] = true，可以将 true 这个结果滚动下去 f[0][0] = true; for (int i = 0; i = 0 && p[j] != '*') { f[i][j] = f[i - 1][j - 1] && (s[i] == p[j] || p[j] == '.'); } // 对应了 p[j] 为 '*' 的情况 else if (p[j] == '*') { f[i][j] = (j - 2 >= 0 && f[i][j - 2]) || (i - 1 >= 0 && f[i - 1][j] && (s[i] == p[j - 1] || p[j - 1] == '.')); } } } return f[n][m]; } } 77. 最长的括号子串 我们定义 dp[i] 表示以下标 i 字符结尾的最长有效括号的长度。 我们将 dp 数组全部初始化为 0 。显然有效的子串一定以 ‘)’ 结尾，因此我们可以知道以 ‘(’ 结尾的子串对应的 dp 值必定为 0 ，我们只需要求解 ‘)’ 在 dp 数组中对应位置的值. 从前往后遍历字符串求解 dp 值，我们每两个字符检查一次: s[i] = ')' 且 s[i-1] = '('，表示字符串形如 ‘......()’，则可推出： dp[i] = dp[i-2] + 2 以进行这样的转移，是因为结束部分的 \"()\" 是一个有效子字符串，并且将之前有效子字符串的长度增加了 2 s[i] = ')' 且 s[i-1] = ')'，表示字符串形如 ‘......))’，则可推出： 如果s[i - dp[i-1] - 1] = '('，则 dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2 考虑如果倒数第二个 ‘)’ 是一个有效子字符串的一部分（记作 subs），对于最后一个‘)’ ，如果它是一个更长子字符串的一部分，那么它一定有一个对应的 ‘(’ ，且它的位置在倒数第二个 ‘)’ 所在的有效子字符串的前面（也就是 subs的前面）。因此，如果子字符串 subs 的前面恰好是 ‘(’ ，那么我们就用 2 加上 subs 的长度（dp[i−1]）去更新 dp[i]。同时，也会把有效子串 “(subs)” 之前的有效子串的长度也加上，也就是再加上 dp[i−dp[i−1]−2]。 最后的答案即为 dp 数组中的最大值 import java.util.*; public class Solution { /** * * @param s string字符串 * @return int整型 */ public int longestValidParentheses (String s) { // write code here int maxans = 0, len = s.length(); int[] dp = new int[len]; for (int i = 1; i = 2 ? dp[i - 2] : 0) + 2; } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') { dp[i] = dp[i - 1] + 2 + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0); } maxans = Math.max(maxans, dp[i]); } } return maxans; } } 78. 打家劫舍(一) import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param nums int整型一维数组 * @return int整型 */ public int rob (int[] nums) { // write code here if(nums.length == 1){ return nums[0]; } else if(nums.length == 2){ return Math.max(nums[0],nums[1]); } int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(nums[0],nums[1]); for (int i = 2; i 79. 打家劫舍(二) 成环形 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param nums int整型一维数组 * @return int整型 */ public int rob (int[] nums) { // write code here int n=nums.length; //在0到n-2范围内找 int rob1=robNoCircle(Arrays.copyOfRange(nums,0,n-1)); //在1到n-1范围内找 int rob2=robNoCircle(Arrays.copyOfRange(nums,1,n)); return Math.max(rob1,rob2); } private int robNoCircle(int[] nums) { // write code here if(nums.length == 1){ return nums[0]; } else if(nums.length == 2){ return Math.max(nums[0],nums[1]); } int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(nums[0],nums[1]); for (int i = 2; i 80. 买卖股票的最好时机(一) 只能交易一次 import java.util.*; public class Solution { /** * * @param prices int整型一维数组 * @return int整型 */ public int maxProfit (int[] prices) { // write code here int len = prices.length; int[][] dp = new int[len][2]; dp[0][1] = -prices[0]; dp[0][0] = 0; for(int i = 1; i 81. 买卖股票的最好时机(二) 不限制交易次数 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * 计算最大收益 * @param prices int整型一维数组 股票每一天的价格 * @return int整型 */ public int maxProfit (int[] prices) { // write code here int len = prices.length; int[][] dp = new int[len][2]; dp[0][1] = -prices[0]; dp[0][0] = 0; for(int i = 1; i 82. 买卖股票的最好时机(三) 只能交易2次 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * 两次交易所能获得的最大收益 * @param prices int整型一维数组 股票每一天的价格 * @return int整型 */ public int maxProfit (int[] prices) { // write code here int len = prices.length; int maxK = 2;//只能交易两次 int[][][] dp = new int[len][maxK+1][2]; for(int i = 0; i = 1; k--){ if (i - 1 == -1) { dp[i][k][0] = 0; dp[i][k][1] = - prices[i]; continue; } dp[i][k][0] = Math.max(dp[i-1][k][0],dp[i-1][k][1] + prices[i]); dp[i][k][1] = Math.max(dp[i-1][k][1],dp[i-1][k-1][0] - prices[i]);//买时算一次交易 } } return dp[len-1][maxK][0]; } } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-16 20:01:46 "},"chapter2/section8/":{"url":"chapter2/section8/","title":"字符串","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 83. 字符串变形 84. 最长公共前缀 85. 验证IP地址 86. 大数加法 字符串 83. 字符串变形 import java.util.*; public class Solution { public String trans(String s, int n) { // write code here String[] temp=s.split(\" \",-1); StringBuilder sb=new StringBuilder(); for(int i=temp.length-1;i>=0;i--){ char[] str=temp[i].toCharArray(); for(int j=0;j=97){ str[j]=(char)(str[j]-32); }else if(str[j]>=65){ str[j]=(char)(str[j]+32); } sb.append(str[j]); } sb.append(i==0?\"\":\" \"); } return sb.toString(); } } 84. 最长公共前缀 纵向扫描法：按列扫描，先验证所有字符串的第一个元素 import java.util.*; public class Solution { /** * * @param strs string字符串一维数组 * @return string字符串 */ public String longestCommonPrefix (String[] strs) { // write code here if (strs == null || strs.length == 0) { return \"\"; } int length = strs[0].length(); int count = strs.length; for (int i = 0; i 85. 验证IP地址 import java.util.*; public class Solution { /** * 验证IP地址 * @param IP string字符串 一个IP地址字符串 * @return string字符串 */ public String solve (String IP) { // write code here return validIPv4(IP) ? \"IPv4\" : (validIPv6(IP) ? \"IPv6\" : \"Neither\"); } private boolean validIPv4(String IP) { //使用limit = -1的split函数，使得字符串末尾或开头有一个'.'或':'也能分割出空的字符串 String[] strs = IP.split(\"\\\\.\", -1); if (strs.length != 4) { return false; } for (String str : strs) { if (str.length() > 1 && str.startsWith(\"0\")) { return false; } try { int val = Integer.parseInt(str); if (!(val >= 0 && val 4 || str.length() == 0) { return false; } try { int val = Integer.parseInt(str, 16);//转换16进制为十进制 } catch (NumberFormatException numberFormatException) { return false; } } return true; } } 86. 大数加法 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * 计算两个数之和 * @param s string字符串 表示第一个整数 * @param t string字符串 表示第二个整数 * @return string字符串 */ public String solve (String s, String t) { // write code here if(s==null||\"\".equals(s)){return t;} if(t==null||\"\".equals(t)){return s;} int a1,a2,carry=0; int ss=s.length()-1; int tt=t.length()-1; StringBuilder str = new StringBuilder(); while (ss>=0||tt>=0) { a1=ss>=0?(s.charAt(ss) - '0'):0;//减去'0'会自动进行ascii码运算 a2=tt>=0?(t.charAt(tt)-'0'):0; int sum=a1+a2+carry; carry=sum/10; str.append(String.valueOf(sum%10));//转为ascii码又转为对应的字符 ss--; tt--; } if(carry!=0){str.append('1');} str.reverse(); return str.toString(); } } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-16 20:35:33 "},"chapter2/section9/":{"url":"chapter2/section9/","title":"双指针","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 87. 合并两个有序的数组 88. 判断是否为回文字符串 89. 合并区间 90. 最小覆盖子串 91. 反转字符串 92. 最长无重复子数组 93. 盛水最多的容器 94. 接雨水问题 双指针 87. 合并两个有序的数组 import java.util.*; public class Solution { public void merge(int A[], int m, int B[], int n) { //src – 源数组。 //srcPos – 源数组中的起始位置。 //dest – 目标数组。 //destPos – 目标数据中的起始位置。 //length – 要复制的数组元素的数量 System.arraycopy(B, 0, A, m, n); //排序算法是 Vladimir Yaroslavskiy、Jon Bentley 和 Joshua Bloch 的双枢轴快速排序 //a – 要排序的数组 Arrays.sort(A); } } 88. 判断是否为回文字符串 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * @param str string字符串 待判断的字符串 * @return bool布尔型 */ public boolean judge (String str) { // write code here if (str.length() == 0) return true; //两个指针，一个从左边开始，一个从右边开始，每次两个 //指针都同时往中间挪，只要两个指针指向的字符不一样就返回false int left = 0; int right = str.length() - 1; while (left 89. 合并区间 import java.util.*; /** * Definition for an interval. * public class Interval { * int start; * int end; * Interval() { start = 0; end = 0; } * Interval(int s, int e) { start = s; end = e; } * } */ public class Solution { //先升序,再模拟 public ArrayList merge(ArrayList intervals) { Collections.sort(intervals, (v1, v2)->v1.start - v2.start); ArrayList res = new ArrayList(); int idx = -1; for(Interval interval : intervals){ if(idx == -1 || interval.start > res.get(idx).end){ //若数组为空，或当前区间的起始位置小于结果list中最后区间的终止位置 //不合并，直接将当前区间加入结果list res.add(interval); idx++; }else{ //合并，选择较大的数作为最后区间的终止位置 res.get(idx).end = Math.max(interval.end, res.get(idx).end); } } return res; } } 90. 最小覆盖子串 给出两个字符串 s 和 t，要求在 s 中找出最短的包含 t 中所有字符的连续子串。 数据范围：0 \\le |S|,|T| \\le100000≤∣S∣,∣T∣≤10000，保证s和t字符串中仅包含大小写英文字母 要求：进阶：空间复杂度 O(n)O(n) ， 时间复杂度 O(n)O(n) 例如： S =\"XDOYEZODEYXNZ\"S=\"XDOYEZODEYXNZ\" T =\"XYZ\"T=\"XYZ\" 找出的最短子串为\"YXNZ\"\"YXNZ\". 注意： 如果 s 中没有包含 t 中所有字符的子串，返回空字符串 “”； 满足条件的子串可能有很多，但是题目保证满足条件的最短的子串唯一。 滑动窗口 import java.util.*; public class Solution { /** * * @param S string字符串 * @param T string字符串 * @return string字符串 */ public String minWindow (String s, String t) { // write code here // l(left): 左边界 // r(right): 右边界 int l = 0, r = 0; // size=r-l+1: 滑动窗口的大小，默认值Integer.MAX_VALUE方便值交换 int size = Integer.MAX_VALUE; // needCount: 当前遍历下，满足t还需要的元素个数，默认值、最大值是t.length，为0时表示滑动窗口内容覆盖了t中所有元素 int needCount = t.length(); // start: 记录有效滑动窗口的起始位置(左边界)，方便后续查找对应的字串 int start = 0; // 字典need: 记录滑动窗口中需要t中各个元素的数量 // ASCII方式存储 [A-Z]：65-90 [a-z]：97-122 // need[97]=2 表示t中需要2个a // t中对应字符的need[]必须>=0 // 若need[] 0) needCount--; // 无论c在不在t中，都要在need中-1 // 目的：利用正负来区分字符是否多余的还是有用的 need[c]--; // needCount==0表示当前窗口满足t中所有元素 if (needCount == 0) { // 判断左边界是否可以收缩 // 如果l对应字符的need[]91. 反转字符串 import java.util.*; public class Solution { /** * 反转字符串 * @param str string字符串 * @return string字符串 */ public String solve (String str) { // write code here return new StringBuilder(str).reverse().toString(); } } 92. 最长无重复子数组 import java.util.*; public class Solution { /** * * @param arr int整型一维数组 the array * @return int整型 */ public int maxLength (int[] arr) { // write code here Queue queue = new LinkedList<>(); int res = 0; for (int c : arr) { while (queue.contains(c)) { //如果有重复的，队头出队 queue.poll(); } //添加到队尾 queue.add(c); res = Math.max(res, queue.size()); } return res; } } 93. 盛水最多的容器 总是移动短的那边的指针，从统计上看不会丢失最大面积。 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param height int整型一维数组 * @return int整型 */ public int maxArea (int[] height) { // write code here int l = 0, r = height.length-1; int ans = 0; while(l94. 接雨水问题 双指针求解,一个指向最左边，一个指向最右边。 最开始的时候如果左边柱子从左往右是递增的，那么这些柱子是不能盛水的，同理最开始的时候如果右边的柱子从右往左是递增的，也是不能盛水的。 确定left和right的值之后，在left和right之间相当于构成了一个桶，桶的高度是最矮的那根柱子。然后我们从两边往中间逐个查找，如果查找的柱子高度小于桶的高度，那么盛水量就是桶的高度减去我们查找的柱子高度，如果查找的柱子大于桶的高度，我们要更新桶的高度。 import java.util.*; public class Solution { /** * max water * @param arr int整型一维数组 the array * @return long长整型 */ public long maxWater (int[] arr) { // write code here if (arr.length = arr[++left]) { water += leftValue - arr[left]; } } else { //如果左边柱子高度大于右边柱子的高度，根据木桶原理， // 桶的高度就是右边柱子的高度 while (left Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-16 21:32:30 "},"chapter2/section10/":{"url":"chapter2/section10/","title":"贪心算法","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 95. 分糖果问题 96. 主持人调度（二） 贪心算法 95. 分糖果问题 一群孩子做游戏，现在请你根据游戏得分来发糖果，要求如下： 每个孩子不管得分多少，起码分到一个糖果。 任意两个相邻的孩子之间，得分较多的孩子必须拿多一些糖果。(若相同则无此限制) 给定一个数组 arrarr 代表得分数组，请返回最少需要多少糖果。 import java.util.*; public class Solution { /** * pick candy * @param arr int整型一维数组 the array * @return int整型 */ public int candy (int[] arr) { // write code here int len = arr.length; if(len 0; i--){ if(arr[i-1] > arr[i]) candy[i-1] = Math.max(candy[i-1],candy[i]+1); } int ans = 0; for(int x : candy) ans+=x; return ans; } } 96. 主持人调度（二） 有 n 个活动即将举办，每个活动都有开始时间与活动的结束时间，第 i 个活动的开始时间是 starti ,第 i 个活动的结束时间是 endi ,举办某个活动就需要为该活动准备一个活动主持人。 一位活动主持人在同一时间只能参与一个活动。并且活动主持人需要全程参与活动，换句话说，一个主持人参与了第 i 个活动，那么该主持人在 (starti,endi) 这个时间段不能参与其他任何活动。求为了成功举办这 n 个活动，最少需要多少名主持人。 解题思路（排序+贪心） 首先建立两个数组分别存储开始时间（记为start）和结束时间（记为end）。 然后分别对start和end数组进行排序。 接着遍历start数组，判断当前开始时间是否大于等于最小的结束时间，如果是，则说明当前主持人就可以搞定（对应当前最小的结束时间的那个活动）；如果否，则需要新增一个主持人，并将end数组下标后移（表示对应的活动已经有人主持）。 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * 计算成功举办活动需要多少名主持人 * @param n int整型 有n个活动 * @param startEnd int整型二维数组 startEnd[i][0]用于表示第i个活动的开始时间，startEnd[i][1]表示第i个活动的结束时间 * @return int整型 */ public int minmumNumberOfHost (int n, int[][] startEnd) { // write code here //初始化两个数组，分别记录开始时间和结束时间 int[] start=new int[n]; int[] end=new int[n]; //将活动的开始和结束时间赋值道start和end数组 for(int i=0;i=end[index]){ index++; } //否则，需要新增主持人 else{ res++; } } return res; } } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-17 17:41:14 "},"chapter2/section11/":{"url":"chapter2/section11/","title":"模拟","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 97. 旋转数组 98. 螺旋矩阵 99. 顺时针旋转矩阵 100. 设计LRU缓存结构 101. 设计LFU缓存结构 模拟 97. 旋转数组 三次翻转： 假设 n=6且 k=2 原始数组: 1 2 3 4 5 6 反转所有数字后 : 6 5 4 3 2 1 反转前 k 个数字后 : 5 6 4 3 2 1 反转后 n-k 个数字后 : 5 6 1 2 3 4 import java.util.*; public class Solution { /** * 旋转数组 * @param n int整型 数组长度 * @param m int整型 右移距离 * @param a int整型一维数组 给定数组 * @return int整型一维数组 */ public int[] solve (int n, int m, int[] a) { // write code here //防止m超过n，做无效的移动 m = m % n; if(m==0||n98. 螺旋矩阵 import java.util.ArrayList; public class Solution { public ArrayList spiralOrder(int[][] matrix) { if(matrix.length == 0) return new ArrayList<>(); //右、下，左，上 int[][] direction = new int[][]{ {1,0},{0,1},{-1,0},{0,-1} }; int row = matrix.length, column = matrix[0].length; boolean[][] isVisited = new boolean[row][column];//判断是否访问过 int len = row * column;//要添加的总数 int moveX = 0, moveY = -1, tmpX = -1, tmpY = -1; int directionIndex = 0; ArrayList res = new ArrayList<>(); for(int i = 0; i = row || tmpY = column || isVisited[tmpX][tmpY]){ //改变方向 directionIndex++; directionIndex %= direction.length; tmpX = moveX + direction[directionIndex][1]; tmpY = moveY + direction[directionIndex][0]; } moveX = tmpX; moveY = tmpY; res.add(matrix[moveX][moveY]); isVisited[moveX][moveY] = true; } return res; } } 99. 顺时针旋转矩阵 import java.util.*; public class Solution { public int[][] rotateMatrix(int[][] matrix, int n) { // write code here int length = matrix.length; //先上下交换 for (int i = 0; i 100. 设计LRU缓存结构 import java.util.*; public class Solution { private int cap; private LinkedHashMap linkedHashMap = new LinkedHashMap<>(); public Solution(int capacity) { // write code here this.cap = capacity; } public int get(int key) { // write code here if (!linkedHashMap.containsKey(key)) { return -1; } // 将 key 变为最近使用 makeRecently(key); return linkedHashMap.get(key); } public void set(int key, int val) { // write code here if (linkedHashMap.containsKey(key)) { // 修改 key 的值，插入的是双向链表的尾部 linkedHashMap.put(key, val); // 将 key 变为最近使用 makeRecently(key); return; } if (linkedHashMap.size() >= this.cap) { // 链表头部就是最久未使用的 key int oldestKey = linkedHashMap.keySet().iterator().next(); linkedHashMap.remove(oldestKey); } // 将新的 key 添加链表尾部 linkedHashMap.put(key, val); } private void makeRecently(int key) { int val = linkedHashMap.get(key); // 删除 key，重新插入到队尾 linkedHashMap.remove(key); linkedHashMap.put(key, val); } } /** * Your Solution object will be instantiated and called as such: * Solution solution = new Solution(capacity); * int output = solution.get(key); * solution.set(key,value); */ 101. 设计LFU缓存结构 import java.util.*; public class Solution { /** * lfu design * @param operators int整型二维数组 ops * @param k int整型 the k * @return int整型一维数组 */ // key 到 val 的映射，我们后文称为 KV 表 private HashMap keyToVal; // key 到 freq 的映射，我们后文称为 KF 表 private HashMap keyToFreq; // freq 到 key 列表的映射，我们后文称为 FK 表，freq对key是一对多的关系 private HashMap> freqToKeys; // 记录最小的频次，避免遍历一遍去找 private int minFreq; // 记录 LFU 缓存的最大容量 private int cap; public int[] LFU (int[][] operators, int k) { // write code here keyToVal = new HashMap<>(); keyToFreq = new HashMap<>(); freqToKeys = new HashMap<>(); this.cap = k; this.minFreq = 0; ArrayList res = new ArrayList<>(); for(int[] op : operators){ if(op[0] == 1){ put(op[1],op[2]); }else{ res.add(get(op[1])); } } //利用流转int[] return res.stream().mapToInt(Integer::valueOf).toArray(); } public int get(int key) { if (!keyToVal.containsKey(key)) { return -1; } // 增加 key 对应的 freq increaseFreq(key); return keyToVal.get(key); } public void put(int key, int val) { if (this.cap ()); freqToKeys.get(1).add(key); // 插入新 key 后最小的 freq 肯定是 1 this.minFreq = 1; } private void increaseFreq(int key) { int freq = keyToFreq.get(key); /* 更新 KF 表 */ keyToFreq.put(key, freq + 1); /* 更新 FK 表 */ // 将 key 从 freq 对应的列表中删除 freqToKeys.get(freq).remove(key); // 将 key 加入 freq + 1 对应的列表中 freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet<>()); freqToKeys.get(freq + 1).add(key); // 如果 freq 对应的列表空了，移除这个 freq if (freqToKeys.get(freq).isEmpty()) { freqToKeys.remove(freq); // 如果这个 freq 恰好是 minFreq，更新 minFreq if (freq == this.minFreq) { this.minFreq++; } } } private void removeMinFreqKey() { // freq 最小的 key 列表 LinkedHashSet keyList = freqToKeys.get(this.minFreq); // 其中最先被插入的那个 key 即最旧的key，就是该被淘汰的 key int deletedKey = keyList.iterator().next(); /* 更新 FK 表 */ keyList.remove(deletedKey); if (keyList.isEmpty()) { freqToKeys.remove(this.minFreq); // 问：这里需要更新 minFreq 的值吗？ } /* 更新 KV 表 */ keyToVal.remove(deletedKey); /* 更新 KF 表 */ keyToFreq.remove(deletedKey); } } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-17 19:54:08 "},"chapter3/section1/":{"url":"chapter3/section1/","title":"格尔","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 第1题 二叉搜索树 第2题 SOCKET ECHO 第3题 简易日志类 格尔软件笔试(java) 第1题 二叉搜索树 package com.bermuda.algorithms.jobTest; import java.util.Stack; /** * 实现要求： * 1、根据已有的代码片段，创建二叉搜索树； * 2、用中序遍历输出排序结果，结果形如：0，1，2 ，3 ，4， 5， 6， 7， 8， 9， * 3、使用递归、非递归二种方式实现遍历； * 4、注意编写代码注释。 */ public class BinarySearchTree { private static class Node{ public int val; public Node left; public Node right; public Node(){} public Node(int val){this.val=val;} } public static void main(String[] args) { final int[] values = { 1, 3, 4, 5, 2, 8, 6, 7, 9, 0 }; System.out.println(\"Create BST: \"); Node root = createBinaryTree(values); System.out.println(\"Traversing the BST with recursive algorithm: \"); inOrderTransvalWithRecursive(root); System.out.println(); System.out.println(\"Traversing the BST with iterative algorithm: \"); inOrderTransvalWithIterate(root); } // 构建二叉树 public static Node createBinaryTree(int[] values) { // 第一个结点为根结点 Node root = new Node(values[0]); for(int i = 1; i nodeStack = new Stack<>(); // 在树上移动的指针 Node cur = root; while(cur != null || !nodeStack.isEmpty()){ //类似递归时左子树的入栈 while(cur != null){ nodeStack.push(cur); cur = cur.left; } if(!nodeStack.isEmpty()){ //处理当前结点，即中序遍历位置 Node node = nodeStack.pop(); System.out.print(node.val + \", \"); //处理右子树 if(node.right != null) cur = node.right; } } } } 第2题 SOCKET ECHO package com.bermuda.algorithms.jobTest; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.ServerSocket; import java.net.Socket; import java.net.SocketException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Iterator; import java.util.Scanner; import java.util.concurrent.*; import java.util.concurrent.atomic.AtomicInteger; import java.util.regex.Pattern; /** * 实现要求： * 1、根据代码片段实现一个简单的SOCKET ECHO程序； * 2、接受到客户端连接后，服务端返回一个欢迎消息; * 3、接受到\"bye\"消息后， 服务端返回一个结束消息，并结束当前连接; * 4、采用telnet作为客户端，通过telnet连接本服务端； * 5、服务端支持接受多个telnet客户端连接; * 6、服务端支持命令操作，支持查看当前连接数、断开指定客户端连接； * 7、注意代码注释书写。 * */ public class EchoApplication { public static void main(String[] args) throws IOException, InterruptedException { final int listenPort = 12345; // 启动服务端 EchoServer server = new EchoServer(listenPort); server.startService(); // 服务端启动后，运行结果示例： /** java -cp ./classes EchoApplication 2020-03-31 16:58:44.049 - Welcome to My Echo Server.(from SERVER) The current connections: Id. Client LogonTime ----------------------------------------------------- 1 127.0.0.1:32328 2020-03-31 16:59:13 2 127.0.0.1:43434 2020-03-31 17:03:02 3 127.0.0.1:39823 2020-03-31 07:03:48 Enter(h for help): h The commands: ---------------------------------------------------- q query current connections d id disconnect client x quit server h help Enter(h for help): d 1 2020-03-31 16:58:44.049 - The connection '127.0.0.1:32328' has been disconnected. The current connections: Id. Client LogonTime ----------------------------------------------------- 1 127.0.0.1:43434 2020-03-31 17:03:02 2 127.0.0.1:39823 2020-03-31 07:03:48 Enter(h for help): x 2020-03-31 16:58:44.049 - The server has exited. Bye! */ // 在telnet控制台输入，服务端直接原文返回输入信息 // 客户端结果示例： /** 2020-03-31 16:58:44.049 - Welcome to My Echo Server.(from SERVER) Enter: hello! 2020-03-31 16:58:55.452 - hello!(from SERVER) Enter: This is KOAL. 2020-03-31 16:59:06.565 - This is KOAL.(from SERVER) Enter: What can i do for you? 2020-03-31 16:59:12.828 - What can i do for you?(from SERVER) Enter: bye! 2020-03-31 16:59:16.502 - Bye bye!(from SERVER) */ } } class EchoServer { private static final int CORE_POOL_SIZE = 5; private static final int MAX_POOL_SIZE = 10; //io密集型 2n private static final int QUEUE_CAPACITY = 20; //任务队列大小 private static final Long KEEP_ALIVE_TIME = 1L; //空闲线程存活的最长时间 private static final TimeUnit TIME_UNIT = TimeUnit.SECONDS; //时间单位 private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss.SSS\"); private static final String RETURN_STRING = \"(from SERVER)\"; private ThreadPoolExecutor threadPool; //创建线程池实例，以应对多个连接 private CopyOnWriteArrayList clientList = new CopyOnWriteArrayList<>(); //存储已连客户端的列表 private int listenPort; //监听接口 public boolean isInteruptMainThread; //是否中断主线程的标志位 public EchoServer(int listenPort){ this.listenPort = listenPort; } //开启服务器 public void startService() { ServerSocket serverSocket; try { //创建服务器Socket serverSocket = new ServerSocket(listenPort); } catch (IOException e) { System.out.println(\"创建服务器Socket失败,\"+e.getMessage()); return; } //创建线程池实例，以应对多个连接 threadPool = new ThreadPoolExecutor( CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, TIME_UNIT, new ArrayBlockingQueue<>(QUEUE_CAPACITY), new NamingThreadFactory(Executors.defaultThreadFactory(),\"服务器线程池\"), new ThreadPoolExecutor.CallerRunsPolicy() //主线程执行多余的任务 ); //启动一条额外线程用来接收用户输入的命令 startCommandThread(this); //用于中断主线程的死循环 while(!isInteruptMainThread){ try { final Socket clientSocket = serverSocket.accept(); //每来一条连接，就启动一条线程与之对应。 threadPool.execute(()->{ //获取socket的输入流与输出流 BufferedReader socketIn = null; PrintWriter socketOut = null; try { socketIn = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); socketOut = new PrintWriter(clientSocket.getOutputStream()); //记录连接到服务器上的客户端 String ip = clientSocket.getInetAddress().getHostAddress()+\":\"+clientSocket.getPort(); Thread curThread = Thread.currentThread(); Client newClient = new Client(ip,DATE_FORMAT.format(new Date()),curThread,socketIn); clientList.add(newClient); //欢迎信息 socketOut.print(DATE_FORMAT.format(new Date())+\" - Welcome to My Echo Server.(from SERVER)\\n\"); socketOut.flush(); String inTemp = \"\"; //中断，让服务器可以随时终止某条连接 while(!inTemp.equals(\"bye\") && !curThread.isInterrupted()){ inTemp = socketIn.readLine();//读取client传来的消息 socketOut.print(DATE_FORMAT.format(new Date())+\" - \"+inTemp+RETURN_STRING+\"\\n\\nEnter: \");//加上日期格式，原封不动地回显 socketOut.flush(); //赶快刷新使client收到，也可以换成socketOut.println(inTemp, ture) } //从列表记录中删除已经断开的连接 Iterator iterator = clientList.iterator(); while(iterator.hasNext()){ Client c = (Client)iterator.next(); if(c.getCurThread() == Thread.currentThread()){ clientList.remove(c); } } socketOut.print(\"\\n\"+DATE_FORMAT.format(new Date())+\" - \"+\"The server has closed connection with u !!!\"+RETURN_STRING+\"\\n\\nEnter: \");//加上日期格式，原封不动地回显 socketOut.flush(); } catch (IOException e) { e.printStackTrace(); } // catch (Exception ie) { // // InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。 // System.out.println(\"test\"); // } finally { try{ if(socketIn != null) socketIn.close(); if(socketOut != null) socketOut.close(); clientSocket.close(); }catch (IOException e){ e.printStackTrace(); } } }); } catch (IOException e) { System.out.println(DATE_FORMAT.format(new Date())+\" - The server has exited. Bye!\"); return; } } } //开启接收命令的线程 private void startCommandThread(final EchoServer echoServer){ //涉及到命令的工具包 final class CommandHelper{ //校验命令的基本合法性 public boolean validateCommand(String input){ input = input.trim().toLowerCase(); if(input.equals(\"\")) return false; String[] command = input.split(\" \"); if(command.length > 2){ return false; } return true; } //判断输入是否是整数 public boolean isInteger(String str) { Pattern pattern = Pattern.compile(\"^[-\\\\+]?[\\\\d]*$\"); return pattern.matcher(str).matches(); } //打印命令无效信息 public void printInvalidInfo(){ System.out.println(\"invalid command !!!\"); System.out.print(\"\\nEnter(h for help): \"); } } new Thread(()->{ //打印欢迎信息 System.out.println(DATE_FORMAT.format(new Date())+\" - Welcome to My Echo Server.(from SERVER)\"); echoServer.printClientList(); //用户输入 Scanner sc = new Scanner(System.in); String input = sc.nextLine(); CommandHelper commandHelper = new CommandHelper(); boolean isShutdown = false; while(!input.equals(\"x\")){ //1. 先校验输入的基本合法性 boolean isValid = commandHelper.validateCommand(input); if(!isValid){ commandHelper.printInvalidInfo(); //继续接收输入 input = sc.nextLine(); continue; } //2. 再处理连接断开命令\"d\" String[] command = input.split(\" \"); if(command.length == 2 && command[0].equals(\"d\") && commandHelper.isInteger(command[1])){ if(!echoServer.closeConnectionWith(Integer.parseInt(command[1]))){ System.out.println(\"client \"+command[1]+\" does not exist !!!\"); } System.out.print(\"\\nEnter(h for help): \"); } //3. 再处理其它命令 else if (command.length == 1){ switch (input){ //打印已连接的客户端列表 case \"q\": echoServer.printClientList(); break; //关闭服务器 case \"x\": echoServer.stopService(); isShutdown = true; break; //帮助 case \"h\": EchoServer.printHelpInfo(); break; default: commandHelper.printInvalidInfo(); } }else commandHelper.printInvalidInfo(); //跳出循环 if(isShutdown) break; //继续接收输入 input = sc.nextLine(); } },\"commandThread\").start(); } //打印帮助信息 public static void printHelpInfo(){ StringBuilder sb = new StringBuilder(); sb.append(\"The commands:\\n\"); sb.append(\"-----------------------------------------------------\\n\"); sb.append(\"q\\t\\tquery current connections\\n\"); sb.append(\"d id\\t\\tdisconnect client\\n\"); sb.append(\"x\\t\\tquit server\\n\"); sb.append(\"h\\t\\thelp\\n\"); sb.append(\"\\nEnter(h for help): \"); System.out.print(sb.toString()); } //关闭和某个客户端的连接 public boolean closeConnectionWith(int id){ if(id - 1 >= clientList.size() || id 第3题 简易日志类 package com.bermuda.algorithms.jobTest; import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; /** * 实现要求： * 1、根据代码片段，参考log4j/slf4j等公共日志库，编写一个自定义的简易日志类； * 2、至少支持文件输出、控制台输出二种日志输出方式，支持同时输出到文件和控制台； * 3、支持DEBUG/INFO/WARN/ERROR四种日志级别； * 4、请合理进行设计模式，进行接口类、抽象类等设计； * 5、注意代码注释书写。 */ public abstract class KLLogger { public static void main(String[] args) { final KLLogger logger = KLLogger.getLogger(KLLogger.class); logger.setAppender(new ConsoleAppender()); logger.setLogLevel(DebugLevel.DEBUG); logger.debug(\"debug 1...\"); logger.info(\"info 1...\"); logger.warn(\"warn 1...\"); logger.error(\"error 1...\"); logger.setAppender(new FileAppender()); logger.setLogLevel(DebugLevel.ERROR); logger.debug(\"debug 2...\"); logger.info(\"info 2...\"); logger.warn(\"warn 2...\"); logger.error(\"error 2...\"); } public static KLLogger getLogger(Class clazz){ KLLoggerFactory loggerFactory = getLoggerFactory(); return loggerFactory.getLogger(clazz.getName()); } public static KLLoggerFactory getLoggerFactory(){ return new MyLoggerFactory(); } protected abstract void setAppender(MyLoggerAppender appender); protected abstract void setLogLevel(DebugLevel debugLevel); protected abstract void debug(String msg); protected abstract void info(String msg); protected abstract void warn(String msg); protected abstract void error(String msg); } interface KLLoggerFactory{ KLLogger getLogger(String name); } /** * 真正的日志实现类 * debug appenders; //当前log的所有输出方式 private DebugLevel currDebugLevel; //当前log的输出等级 public MyLogger(String name) { this.name = name; } public void setAppender(MyLoggerAppender appender) { if(appenders == null) appenders = new ArrayList<>(); appenders.add(appender); } public void setLogLevel(DebugLevel debugLevel) { this.currDebugLevel = debugLevel; } //遍历所有的打印方式，进行日志输出 private void print(String msg, String level){ for(MyLoggerAppender appender : appenders){ appender.print(\"[\"+level+\"] \"+DATE_FORMAT.format(new Date())+\" \"+name+\" : \"+msg); } } public void debug(String msg) { //若debug Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-18 18:10:00 "},"chapter3/section2/":{"url":"chapter3/section2/","title":"360","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1. 2. 360 1. public static void main(String[] args) { Scanner sc = new Scanner(System.in); //学生人数 int num = sc.nextInt(); //平时成绩比例和期末成绩比例 int commonPerc = sc.nextInt(), finalPerc = sc.nextInt(); //所有学生的期末成绩 int[] finalScores = new int[num]; for(int i = 0; i = 0; i--){ if(i == num-1){ score = (curCommonScore * commonPerc + finalScores[i] * finalPerc) / 100.0; }else{ //如果与之前的期末成绩相等 if(finalScores[i] == finalScores[i+1]){ score = (curCommonScore * commonPerc + finalScores[i] * finalPerc) / 100.0; }else{ score = (--curCommonScore * commonPerc + finalScores[i] * finalPerc) / 100.0; } } if(score > 60.0) res++; } System.out.println(res); } 2. public static void main(String[] args) { Scanner sc = new Scanner(System.in); try{ //棋子个数 int total = sc.nextInt(); //操作次数 int opNum = sc.nextInt(); //具体的操作 int[][] opArray = new int[opNum][2]; for(int i = 0; i Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-18 18:11:29 "},"chapter4/section1/":{"url":"chapter4/section1/","title":"双指针","keywords":"","body":"双指针 713. 乘积小于K的子数组 public static int numSubarrayProductLessThanK(int[] nums, int k) { //if(k = k) product /= nums[left++]; result += right - left + 1; right++; } return result; } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-18 18:14:45 "},"chapter5/section1/":{"url":"chapter5/section1/","title":"数学","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1. n的阶乘的数字有多少个0 2. 通过位运算将两个数相加 3. dijkstra算法 4. prim算法 5. 多矩阵相乘 6. 两数之和 7. 找出两个排序数组中的中位数 数学 1. n的阶乘的数字有多少个0 public long countZeros(long n){ long count = 0; while(n != 0){ n = n / 5; count += n; } return count; } 2. 通过位运算将两个数相加 public int add(int num1,int num2){ int temp1 = 0,temp2 = 0; while(num2 != 0){ temp1 = num1 ^ num2; temp2 = (num1 & num2) 3. dijkstra算法 Graph.java package com.bermuda.algorithms.dijkstra; import java.util.ArrayList; import java.util.List; import java.util.PriorityQueue; import java.util.Queue; public class Graph { /* * 顶点 */ private List vertexs; /* * 边 */ private int[][] edges; /* * 没有访问的顶点 */ private Queue unVisited; public Graph(List vertexs, int[][] edges) { this.vertexs = vertexs; this.edges = edges; initUnVisited(); } /* * 搜索各顶点最短路径 */ public void search(){ while(!unVisited.isEmpty()){ Vertex vertex = unVisited.element(); //顶点已经计算出最短路径，设置为\"已访问\" vertex.setMarked(true); //获取所有\"未访问\"的邻居 List neighbors = getNeighbors(vertex); //更新邻居的最短路径 updatesDistance(vertex, neighbors); pop(); } System.out.println(\"search over\"); } /* * 更新所有邻居的最短路径 */ private void updatesDistance(Vertex vertex, List neighbors){ for(Vertex neighbor: neighbors){ updateDistance(vertex, neighbor); } } /* * 更新邻居的最短路径 */ private void updateDistance(Vertex vertex, Vertex neighbor){ int distance = getDistance(vertex, neighbor) + vertex.getPath(); if(distance (); for (Vertex v : vertexs) { unVisited.add(v); } } /* * 从未访问顶点集合中删除已找到最短路径的节点 */ private void pop() { unVisited.poll(); } /* * 获取顶点到目标顶点的距离 */ private int getDistance(Vertex source, Vertex destination) { int sourceIndex = vertexs.indexOf(source); int destIndex = vertexs.indexOf(destination); return edges[sourceIndex][destIndex]; } /* * 获取顶点所有(未访问的)邻居 */ private List getNeighbors(Vertex v) { List neighbors = new ArrayList(); int position = vertexs.indexOf(v); Vertex neighbor = null; int distance; for (int i = 0; i Vertex.java package com.bermuda.algorithms.dijkstra; public class Vertex implements Comparable{ /** * 节点名称(A,B,C,D) */ private String name; /** * 最短路径长度 */ private int path; /** * 节点是否已经出列(是否已经处理完毕) */ private boolean isMarked; public Vertex(String name){ this.name = name; this.path = Integer.MAX_VALUE; //初始设置为无穷大 this.setMarked(false); } public Vertex(String name, int path){ this.name = name; this.path = path; this.setMarked(false); } @Override public int compareTo(Vertex o) { return o.path > path?-1:1; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getPath() { return path; } public void setPath(int path) { this.path = path; } public void setMarked(boolean marked) { isMarked = marked; } public boolean isMarked(){ return isMarked; } } 4. prim算法 package com.bermuda.algorithms.prim; import java.util.ArrayList; import java.util.List; public class Prim { static int MAX = Integer.MAX_VALUE; public static void main(String[] args) { int[][] map = new int[][] { { 0, 10, MAX, MAX, MAX, 11, MAX, MAX, MAX }, { 10, 0, 18, MAX, MAX, MAX, 16, MAX, 12 }, { MAX, MAX, 0, 22, MAX, MAX, MAX, MAX, 8 }, { MAX, MAX, 22, 0, 20, MAX, MAX, 16, 21 }, { MAX, MAX, MAX, 20, 0, 26, MAX, 7, MAX }, { 11, MAX, MAX, MAX, 26, 0, 17, MAX, MAX }, { MAX, 16, MAX, MAX, MAX, 17, 0, 19, MAX }, { MAX, MAX, MAX, 16, 7, MAX, 19, 0, MAX }, { MAX, 12, 8, 21, MAX, MAX, MAX, MAX, 0 } }; prim(map, map.length); } public static void prim(int[][] graph, int n){ char[] c = new char[]{'A','B','C','D','E','F','G','E','F'}; int[] lowcost = new int[n]; //到新集合的最小权 int[] mid= new int[n];//存取前驱结点 List list=new ArrayList();//用来存储加入结点的顺序 int i, j, min, minid , sum = 0; //初始化辅助数组 for(i=1;igraph[minid][j]) { lowcost[j]=graph[minid][j]; mid[j]=minid; } } } System.out.println(\"sum:\" + sum); list.forEach(s-> System.out.println(s.toString())); } } 5. 多矩阵相乘 动态规划 public void martixChainMultipy(int[] p,int[][] m,int[][] s){ martixChain(p,m,s); traceback(s,0,p.length-1); } private void martixChain(int[] p,int[][] m,int[][] s){ int n = p.length - 1; for(int i = 1;i 6. 两数之和 /** * Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. * @param nums * @param target * @return */ public int[] twoSum(int[] nums,int target){ Map numsMap = new HashMap(); for(int step = 0;step 7. 找出两个排序数组中的中位数 /** * Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 * @param nums1 * @param nums2 * @return */ public double findMedianSortedArrays(int[] nums1, int[] nums2) { if(nums1 == null || nums2 == null){ return -1; } if(nums1.length == 0){ return findMedianSortedArray(nums2); } if(nums2.length == 0){ return findMedianSortedArray(nums1); } int m = nums1.length,n = nums2.length; int[] tempNums1 = nums1,tempNums2 = nums2; //保证tempNums1是最短的 if(m > n){ tempNums1 = nums2; tempNums2 = nums1; m = tempNums1.length; n = tempNums2.length; } int l1 = 0,l2 = 0,r1 = 0,r2 = 0,c1,c2,low = 0,high = 2*m;//2m+1 while(low r2){ high = c1 - 1; }else if(l2 > r1){ low = c1 + 1; }else{ break; } } return (Math.max(l1,l2) + Math.min(r1,r2))/2.0; } private double findMedianSortedArray(int[] nums){ if(nums == null || nums.length Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-18 18:57:41 "},"chapter5/section2/":{"url":"chapter5/section2/","title":"排序算法","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1. 快速排序 2. 归并排序 3. 基尔排序 4. 插入排序 5. 冒泡排序 6. 选择排序 排序算法 1. 快速排序 先序遍历 public void quickSort(int[] nums,int begin,int end){ if(nums == null || nums.length = end){ return; } int index = process(nums,begin,end); quickSort(nums,0,index-1); quickSort(nums,index+1,end); } private int process(int[] nums,int begin,int end){ int key = nums[begin]; while (begin = nums[begin] && begin 2. 归并排序 后序遍历 public void mergeSort(int[] nums,int start,int end,int[] tempNums){ if(nums == null || nums.length = end){ return; } int mid = (start + end) / 2; mergeSort(nums,start,mid,tempNums); mergeSort(nums,mid + 1,end,tempNums); mergeArray(nums,start,mid,end,tempNums); } private void mergeArray(int[] nums,int start,int mid,int end,int[] tempNums){ if(nums == null || nums.length = end){ return; } int m = start,endM = mid; int n = mid + 1,endN = end; int tempPoint = 0; while (m 3. 基尔排序 public void shellSort(int[] nums){ if(nums == null || nums.length 0){ for(int i = interval;i interval - 1 && nums[j - interval] > temp){ nums[j] = nums[j - interval]; j -= interval; } nums[j] = temp; } interval = (interval - 1)/3; } } 4. 插入排序 public void insertSort(int[] nums){ if(nums == null || nums.length == 0){ return; } int temp,j,numsLength = nums.length; for(int i = 1;i 0 && nums[j-1] >= temp){ nums[j] = nums[--j]; } nums[j] = temp; } } 5. 冒泡排序 public void bubbleSort(int[] nums){ if(nums == null || nums.length == 0){ return; } int numsLength = nums.length; for(int i = 0;i nums[j]){ nums[j] = nums[j] ^ nums[j - 1]; nums[j - 1] = nums[j] ^ nums[j - 1]; nums[j] = nums[j] ^ nums[j - 1]; } } } } 6. 选择排序 public void selectSort(int[] nums){ if(nums == null || nums.length nums[j]){ minNum = j; } } if(minNum != i){ temp = nums[minNum]; nums[minNum] = nums[i]; nums[i] = temp; } } } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-18 19:02:23 "},"chapter5/section3/":{"url":"chapter5/section3/","title":"字符串","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1. 正则匹配 2. 最长不重复子串 3. kmp匹配算法 4. 最长回文子串 字符串 1. 正则匹配 public boolean isMatch(String s, String p) { /* 'match' below including . f(i,j) means s where s.len=i matches p where p.len=j f(i,j) = if (p_j-1 != * ) f(i-1, j-1) and s_i-1 matches p_j-1 if (p_j-1 == * ) * matches zero times: f(i,j-2) or * matches at least one time: f(i-1,j) and s_i-1 matches p_j-2 */ if (!p.isEmpty() && p.charAt(0) == '*') { return false; // invalid p } boolean[][] dp = new boolean[s.length() + 1][p.length() + 1]; // initialize dp(0,0) dp[0][0] = true; // dp(k,0) and dp(0,2k-1) where k>=1 are false by default // initialize dp(0,2k) where p_2k-1 = * for any k>=1 for (int j = 1; j 2. 最长不重复子串 /** * Given \"abcabcbb\", the answer is \"abc\", which the length is 3. Given \"bbbbb\", the answer is \"b\", with the length of 1 * @param src * @return */ public int lengthOfLongestSubstring(String src) { if(src == null || src.length() charMap = new HashMap(); int maxLength = 0; while (end 3. kmp匹配算法 private int[] getNext(String pattern){ if(pattern == null || pattern.length() source.length()){ return -1; } int srcPoint = 0,tarPoint = 0,srcLength = source.length(),ptnLength = pattern.length(); int[] next = getNext(pattern); while (srcPoint 4. 最长回文子串 /** * Input: \"babad\" Output: \"bab\" Input: \"cbbd\" Output: \"bb\" * @param src * @return */ public String longestPalindrome(String src) { if(src == null || src.length() i)?Math.min(right - i,p[iMirror]):0; while(specialString[i+1+p[i]] == specialString[i-1-p[i]]){ p[i]++; } //更新center和right if(p[i] > right - i){ center = i; right = i + p[i]; } } int maxLength = 0,centerIndex = 0; for(int i = 1; i maxLength){ maxLength = p[i]; centerIndex = i; } } System.out.println(centerIndex+\"$\"+maxLength); int temp = (centerIndex - 1 - maxLength) / 2; return src.substring(temp,temp+maxLength); } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-18 19:06:51 "},"chapter5/section4/":{"url":"chapter5/section4/","title":"递归算法","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1. FJ的字符串 2. Sine之舞 3. 最长三角形 递归算法 1. FJ的字符串 问题描述 　　FJ在沙盘上写了这样一些字符串： 　　A1 = “A” 　　A2 = “ABA” 　　A3 = “ABACABA” 　　A4 = “ABACABADABACABA” 　　… … 　　你能找出其中的规律并写所有的数列AN吗？ 输入格式 　　仅有一个数：N ≤ 26。 输出格式 　　请输出相应的字符串AN，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。 样例输入 3 样例输出 ABACABA package 递归算法; import java.util.Scanner; public class Step1 { public static void main(String[] args){ Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); scanner.close(); System.out.println(fun(n)); } public static String fun(int n){ if(1 == n){ return \"A\"; } return fun(n-1)+(char)('A'+n-1)+fun(n-1); } } 2. Sine之舞 问题描述 　　最近FJ为他的奶牛们开设了数学分析课，FJ知道若要学好这门课，必须有一个好的三角函数基本功。所以他准备和奶牛们做一个“Sine之舞”的游戏，寓教于乐，提高奶牛们的计算能力。 　　不妨设 　　An=sin(1–sin(2+sin(3–sin(4+...sin(n))...) 　　Sn=(...(A1+n)A2+n-1)A3+...+2)An+1 　　FJ想让奶牛们计算Sn的值，请你帮助FJ打印出Sn的完整表达式，以方便奶牛们做题。 输入格式 　　仅有一个数：Npackage 递归算法; import java.util.Scanner; public class Step2 { public static void main(String[] args){ Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); scanner.close(); System.out.println(a(n)); } public static String s(int n){ int count = n; StringBuilder sb = new StringBuilder(); for(int i = 1;ipackage 递推算法; import java.util.Scanner; public class Step1 { public static void main(String[] args){ Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); scanner.close(); System.out.println(s(n)); } public static String s(int n){ int count = n; StringBuilder sb = new StringBuilder(); for(int i = 1;i3. 最长三角形 动态规划 在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。 只需要求出这个最大和即可，不必给出具体路径。 三角形的行数大于1小于等于100，数字为 0 - 99 输入格式： 5 //表示三角形的行数 接下来输入三角形 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 要求输出最大和 package 递归算法; import java.util.Scanner; /* * 从递归开始：Step1 */ public class Step3 { private int[][] array ; static int n; public static void main(String[] args) { Step3 step1 = new Step3(); step1.start(); System.out.println(step1.MaxSum(1, 1)); } public int MaxSum(int i,int j) { if(i == n) { return array[i][j]; } return Math.max(MaxSum(i+1, j), MaxSum(i+1, j+1))+array[i][j]; } public void start() { Scanner scanner = new Scanner(System.in); n = scanner.nextInt(); array = new int[n+1][n+1]; for(int i = 1; i Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-18 19:40:44 "},"chapter5/section5/":{"url":"chapter5/section5/","title":"动态规划","keywords":"","body":"动态规划 1. k好数 问题描述 如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。求L位K进制数中K好数的数目。例如K = 4，L = 2的时候，所有K好数为11、13、20、22、30、31、33 共7个。由于这个数目很大，请你输出它对1000000007取模后的值。 输入格式 输入包含两个正整数，K和L。 输出格式 输出一个整数，表示答案对1000000007取模后的值。 样例输入 4 2 样例输出 7 数据规模与约定 对于30%的数据，K^L package 动态规划; import java.util.Arrays; import java.util.Scanner; //D:\\Program Files (x86)\\eclipse for java\\eclipse for storing\\ExerciseOfCalculation\\src\\动态规划\\kgood.png public class Step2 { private static final int num = 1000000007; public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int K = scanner.nextInt(); int L = scanner.nextInt(); scanner.close(); // int L = 2; // int K = 4; int[][] dp = new int[101][101]; Arrays.fill(dp[1], 1); for(int i = 2;iCopyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-18 19:41:17 "},"chapter5/section6/":{"url":"chapter5/section6/","title":"回溯算法","keywords":"","body":"回溯算法 1. 2n皇后 问题描述 　　给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后， 使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。 问总共有多少种放法？n小于等于8。 输入格式 　　输入的第一行为一个整数n，表示棋盘的大小。 　　接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。 输出格式 　　输出一个整数，表示总共有多少种放法。 样例输入 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 样例输出 2 样例输入 4 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 样例输出 0 package 回溯算法; import java.util.*; /** * 单皇后解法 * * @author Bermuda * */ class SingleQueen implements Runnable { private static int n = 4; private int[] array; public SingleQueen() { array = new int[n]; } public SingleQueen(int[] array) { SingleQueen.n = array.length; this.array = new int[n]; } @Override public void run() { queen(array); } public void queen(int[] array) { Arrays.fill(array, -1); int row = 0; int count = 0; while (row >= 0 && row = 0 && row = n) { break; } else if (chessBoard[row][array[row]] == 0) { array[row]++; } } if (array[row] >= n) { } else if (chessBoard[row][array[row]] == 0) { continue; } if (array[row] = 0 && row = n) { break; } else if (chessBoard[row][array[row]] == 0) { array[row]++; } } if (array[row] >= n) { } else if (chessBoard[row][array[row]] == 0) { continue; } if (array[row] 0 ? true : false; } public boolean check(int row, int[] array) { for (int perRow = 0; perRow Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-18 19:42:28 "},"chapter5/section7/":{"url":"chapter5/section7/","title":"精度算法","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1. 大数加法 2. 大数乘法 3. 大数阶乘 精度算法 1. 大数加法 题目： 输入两个整数a和b，输出这两个整数的和。a和b都不超过100位。 算法描述 　　由于a和b都比较大，所以不能直接使用语言中的标准数据类型来存储。对于这种问题，一般使用数组来处理。 　　定义一个数组A，A[0]用于存储a的个位，A[1]用于存储a的十位，依此类推。同样可以用一个数组B来存储b。 　　计算c = a + b的时候，首先将A[0]与B[0]相加，如果有进位产生，则把进位（即和的十位数）存入r，把和的个位数存入C[0]，即C[0]等于(A[0]+B[0])%10。然后计算A[1]与B[1]相加，这时还应将低位进上来的值r也加起来，即C[1]应该是A[1]、B[1]和r三个数的和．如果又有进位产生，则仍可将新的进位存入到r中，和的个位存到C[1]中。依此类推，即可求出C的所有位。 　　最后将C输出即可。 输入格式 　　输入包括两行，第一行为一个非负整数a，第二行为一个非负整数b。两个整数都不超过100位，两数的最高位都不是0。 输出格式 　　输出一行，表示a + b的值。 样例输入 20100122201001221234567890 2010012220100122 样例输出 20100122203011233454668012 package 精度算法; import java.util.Scanner; public class Step1 { private static final int MAX_SIZE = 1000; public static void main(String[] args) { Scanner scanner = new Scanner(System.in); String a = scanner.nextLine(); String b = scanner.nextLine(); scanner.close(); add(stringToInts(a), stringToInts(b)); } public static void add(int[] a, int[] b) { int[] result = new int[MAX_SIZE]; int forward = 0; for(int i = 0;i=0;i--) { if(result[i] != 0) { break; } } for(; i>= 0 ;i--) { System.out.print(result[i]); } } public static int[] stringToInts(String s) { int[] n = new int[MAX_SIZE]; int i = 0; int j = s.length(); for (; i 2. 大数乘法 package 精度算法; import java.util.Arrays; import java.util.Scanner; public class Step2 { private static final int MAX_SIZE = 1000; public static void main(String[] args) { Scanner scanner = new Scanner(System.in); String a = scanner.nextLine(); String b = scanner.nextLine(); scanner.close(); multiply(stringToInts(a), stringToInts(b),b.length()); } public static void multiply(int[] a,int[] b,int bLength) { if(null == a || null == b) { return; } int[] result = new int[MAX_SIZE]; Arrays.fill(result, 0); int temp; for(int i = 0;i=0;i--) { if(result[i] != 0) { break; } } for(; i>= 0 ;i--) { System.out.print(result[i]); } } public static int[] stringToInts(String s) { if(null == s) { return null; } int[] n = new int[MAX_SIZE]; int i = 0; int j = s.length(); for (; i 3. 大数阶乘 问题描述 　　输入一个正整数n，输出n!的值。 　　其中n!=1*2*3*…*n。 算法描述 　　n!可能很大，而计算机能表示的整数范围有限，需要使用高精度计算的方法。使用一个数组A来表示一个大整数a，A[0]表示a的个位，A[1]表示a的十位，依次类推。 　　将a乘以一个整数k变为将数组A的每一个元素都乘以k，请注意处理相应的进位。 　　首先将a设为1，然后乘2，乘3，当乘到n时，即得到了n!的值。 输入格式 　　输入包含一个正整数n，npackage 精度算法; import java.util.Scanner; public class Step3 { private static final int MAX_SIZE = 1000; public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); scanner.close(); factorial(n); } public static void factorial(int n) { int[] a = stringToInts(\"1\"); int forward; int temp; for(int i=2;i=0;i--) { if(result[i] != 0) { break; } } for(; i>= 0 ;i--) { System.out.print(result[i]); } } public static int[] stringToInts(String s) { int[] n = new int[MAX_SIZE]; int i = 0; int j = s.length(); for (; i Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-18 19:44:30 "},"chapter5/section8/":{"url":"chapter5/section8/","title":"贪心算法","keywords":"","body":"贪心算法 1. 完美的代价 问题描述 　　回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。 　　交换的定义是：交换两个相邻的字符 　　例如mamad问题描述 　　回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。 　　交换的定义是：交换两个相邻的字符 　　例如mamad 　　第一次交换 ad : mamda 　　第二次交换 md : madma 　　第三次交换 ma : madam (回文！完美！) 输入格式 　　第一行是一个整数N，表示接下来的字符串的长度(N package 贪心算法; import java.util.Scanner; class Task implements Runnable{ private char[] cString = new char[] {'m','a','m','a','d'}; public Task() { } public Task(char[] cString) { this.cString = cString; } @Override public synchronized void run() { //总步数 int sum = 0; //输入字符串不能达到目标要求的标志 int flag = 0; //不止一个无相同的字符 int single = 0; //代码优化 int n = cString.length; //尾指针指向 int point = n-1; for (int i = 0;i = i;j--) { if(i == j) { if(n % 2 == 0 || single != 0) { flag = 1; break; } sum += n/2 - i; single = 1; break; } if(cString[i] == cString[j]) { for(int k = j;k Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-18 19:45:40 "},"chapter6/section1/":{"url":"chapter6/section1/","title":"入门练习","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1. 十字型的徽标 2. 分割矩阵 3. 代分数表示 4. 三羊生瑞气 5. 最小公倍数 算法入门练习 1. 十字型的徽标 package gq.ever; import java.util.Scanner; /** * 小明为某机构设计了一个十字型的徽标（并非红十字会啊），如下所示： ..$$$$$$$$$$$$$.. ..$...........$.. $$$.$$$$$$$$$.$$$ $...$.......$...$ $.$$$.$$$$$.$$$.$ $.$...$...$...$.$ $.$.$$$.$.$$$.$.$ $.$.$...$...$.$.$ $.$.$.$$$$$.$.$.$ $.$.$...$...$.$.$ $.$.$$$.$.$$$.$.$ $.$...$...$...$.$ $.$$$.$$$$$.$$$.$ $...$.......$...$ $$$.$$$$$$$$$.$$$ ..$...........$.. ..$$$$$$$$$$$$$.. 对方同时也需要在电脑dos窗口中以字符的形式输出该标志，并能任意控制层数。 * @author Bermuda * */ public class CrossGraph { public static void main(String[] args) { char cross[][] = new char[125][125]; Scanner scanner = new Scanner(System.in); int floor = scanner.nextInt(); int surround = 9; for(int i = 0; i 1){ surround += 4; } } for(int i = 0; i 2 && i == 0){ cross[i][j] = '$'; } if(j > 2 && i == 1){ cross[i][j] = '.'; } }else if(i == 2){ if(j = i-3+1 && j = i-3+1 && j 2. 分割矩阵 package gq.ever; /** * 如下图所示，3 x 3 的格子中填写了一些整数。 +--*--+--+ |10* 1|52| +--****--+ |20|30* 1| *******--+ | 1| 2| 3| +--+--+--+ 我们沿着图中的星号线剪开，得到两个部分，每个部分的数字和都是60。 本题的要求就是请你编程判定：对给定的m x n 的格子中的整数，是否可以分割为两个部分，使得这两个区域的数字和相等。 如果存在多种解答，请输出包含左上角格子的那个区域包含的格子的最小数目。 如果无法分割，则输出 0。 * @author Bermuda * */ public class CutGrid { public static void main(String[] args) { } } 3. 代分数表示 package gq.ever; import java.util.Scanner; /** * 100 可以表示为带分数的形式：100 = 3 + 69258 / 714。 * 还可以表示为：100 = 82 + 3546 / 197。 * 注意特征：带分数中，数字1~9分别出现且只出现一次（不包含0）。 * 类似这样的带分数，100 有 11 种表示法。 * @author Bermuda * */ public class MixedNumber { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int goal = scanner.nextInt(); int count = 0; for(int i = 1; i 9-preChar.length()){ break; }else{ continue; } } } System.out.println(count); } } 4. 三羊生瑞气 package gq.ever; /** * 三羊生瑞气：祥瑞生辉+三羊献瑞=三羊生瑞气 * @author Bermuda * */ public class ThreeSheep { public static void main(String[] args) { for(int a = 1; a 5. 最小公倍数 package gq.ever; import java.util.Scanner; /** * 最小公倍数 * 求最小公倍数算法： 最小公倍数=两整数的乘积÷最大公约数 * @author Bermuda * */ public class LCM { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int[] a = new int[3]; int i = 0; while(i a[k+1]){ int tmp = a[k]; a[k] = a[k+1]; a[k+1] = tmp; } } } int tmp = a[2]; while(true){ if(a[2] % a[0] == 0 && a[2] % a[1] == 0){ System.out.println(a[2]); break; }else{ a[2] += tmp; } } } } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-18 19:54:25 "},"chapter6/section2/":{"url":"chapter6/section2/","title":"基础练习","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1. 和为n的回文数 2. 乘法算式 3. 还款计算 4. 滑动解锁 5. 排列序数 6. 字符串比较 基础练习 1. 和为n的回文数 package gq.ExerciseOfFoundation; import java.util.Scanner; /** * 123321是一个非常特殊的数，它从左边读和从右边读是一样的。 * 输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。 * @author Bermuda * */ public class Palindrome { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int sum = scanner.nextInt(); for(int i = 10000; i 2. 乘法算式 package gq.test; public class 乘法算式 { static int[] a = new int[10]; public static void main(String[] args) { for(int i = 100;i 0){ a[key%10] += 1; //核心代码,计算每个数字出现了多少次 key /= 10; } } public static boolean validate(){ for(int i = 0; i 3. 还款计算 银行贷款的等额本息还款方法是： 每月还固定的金额，在约定的期数内正好还完（最后一个月可能会有微小的零头出入）。 比如说小明在银行贷款1万元。贷款年化利率为5%，贷款期限为24个月。 则银行会在每个月进行结算： 结算方法是：计算本金在本月产生的利息： 本金 x (年利率/12) 则本月本金结余为：本金 + 利息 - 每月固定还款额 = 还欠银行多少钱 计算结果会四舍五入到“分”。 经计算，此种情况下，固定还款额应为：438.71 这样，第一月结算时的本金余额是： 9602.96 第二个月结算： 9204.26 第三个月结算： 8803.9 .... 最后一个月如果仍按固定额还款，则最后仍有0.11元的本金余额， 但如果调整固定还款额为438.72, 则最后一个月会多还了银行0.14元。 银行会选择最后本金结算绝对值最小的情况来设定 每月的固定还款额度。 如果有两种情况最后本金绝对值相同，则选择还款较少的那个方案。 本题的任务是已知年化利率，还款期数，求每月的固定还款额度。 假设小明贷款为1万元，即：初始本金=1万元。 年化利率的单位是百分之多少。 期数的单位为多少个月。 输入为2行， 第一行为一个小数r，表示年率是百分之几。(0package gq.test; import java.util.Scanner; public class 还款计算 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); double rate = scanner.nextDouble()/100/12; int deadline = scanner.nextInt(); int total = 10000; double perMin = total/deadline; double min = 0x7fffffff; // long a = 0x7fffffff; double perReturn = 0; for(double i = perMin;;i+=0.01){ double money = total; for(int j = 0;j Math.abs(money)){ //核心判断 min = money; perReturn = i; }else break; } System.out.println(getInt(perReturn)); } public static int getInt(double money){ return (int)(money * 100 + 0.5);//四舍五入“+0.5” } } 4. 滑动解锁 滑动解锁是智能手机一项常用的功能。你需要在3x3的点阵上，从任意一个点开始，反复移动到一个尚未经过的\"相邻\"的点。这些划过的点所组成的有向折线，如果与预设的折线在图案、方向上都一致，那么手机将解锁。 所谓两个点“相邻”：当且仅当以这两个点为端点的线段上不存在尚未经过的点。 此外，许多手机都约定：这条折线还需要至少经过4个点。 为了描述方便，我们给这9个点从上到下、从左到右依次编号1-9。即如下排列： 1 2 3 4 5 6 7 8 9 那么1->2->3是非法的，因为长度不足。 1->3->2->4也是非法的，因为1->3穿过了尚未经过的点2。 2->4->1->3->6是合法的，因为1->3时点2已经被划过了。 某大神已经算出：一共有389112种不同的解锁方案。没有任何线索时，要想暴力解锁确实很难。 不过小Hi很好奇，他希望知道，当已经瞥视到一部分折线的情况下，有多少种不同的方案。 遗憾的是，小Hi看到的部分折线既不一定是连续的，也不知道方向。 例如看到1-2-3和4-5-6， 那么1->2->3->4->5->6，1->2->3->6->5->4, 3->2->1->6->5->4->8->9等都是可能的方案。 你的任务是编写程序，根据已经瞥到的零碎线段，求可能解锁方案的数目。 输入： 每个测试数据第一行是一个整数N(0 package gq.test; import java.util.Scanner; public class 滑动解锁 { private static boolean f[] = new boolean[10]; private static int N; private static int[][] path; static int count = 0; public static boolean isOK(int a,int b){ int[][] dig = { {1,3,2},{1,7,4},{1,9,5},{2,8,5},{3,7,5},{3,9,6},{4,6,5},{7,9,8} }; for(int i = 0;i=2){//当process数组里面至少有2个数时开始判断，代表我要选取最近划中的2个数字是否合法 int a = process[step-2]; int b = process[step-1]; if(!isOK(a,b))return; } if(step==number){//判断是否存在此数组，存在则继续，不存在直接返回代表不符合 for(int i = 0;inumber)return; for(int i = 1;i4?N:4;i5. 排列序数 X星系的某次考古活动发现了史前智能痕迹。 这是一些用来计数的符号，经过分析它的计数规律如下： （为了表示方便，我们把这些奇怪的符号用a~q代替） abcdefghijklmnopq 表示0 abcdefghijklmnoqp 表示1 abcdefghijklmnpoq 表示2 abcdefghijklmnpqo 表示3 abcdefghijklmnqop 表示4 abcdefghijklmnqpo 表示5 abcdefghijklmonpq 表示6 abcdefghijklmonqp 表示7 ..... 在一处石头上刻的符号是： bckfqlajhemgiodnp 请你计算出它表示的数字是多少？295797692 package gq.test; import java.util.Arrays; import java.util.Scanner; public class 排列序数 { public static String letterString; public static char[] s; public static boolean[] visited; public static int count; public static void main(String[] args) { int[] que = new int[18]; que[0] = 1; for(int i=1; i 6. 字符串比较 我们需要一个新的字符串比较函数compare(s1, s2). 对这个函数要求是： 1. 它返回一个整数，表示比较的结果。 2. 结果为正值，则前一个串大，为负值，后一个串大，否则，相同。 3. 结果的绝对值表示：在第几个字母处发现了两个串不等。 下面是代码实现。对题面的数据，结果为： -3 2 5 package gq.test; public class 字符串比较 { static int compare(String s1, String s2) { if(s1==null && s2==null) return 0; if(s1==null) return -1; if(s2==null) return 1; if(s1.isEmpty() && s2.isEmpty()) return 0; if(s1.isEmpty()) return -1; if(s2.isEmpty()) return 1; char x = s1.charAt(0); char y = s2.charAt(0); if(xy) return 1; int t = compare(s1.substring(1),s2.substring(1)); if(t==0) return 0; return t!=0?(tCopyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-18 20:14:19 "},"chapter6/section3/":{"url":"chapter6/section3/","title":"进阶练习","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1. 抢金块 2. 银行家算法 3. 硬币问题 4. 冰雹数 5. 凑算式 6. 搭积木 7. 分小组 8. 密码脱落 9. 平方怪圈 10. 有奖猜谜 进阶练习 1. 抢金块 抢金块(dp入门) 【问题描述】 地面上有一些格子，每个格子上面都有金块，但不同格子上的金块有不同的价值，你一次可以跳S至T步(2≤S＜T≤10)。例如S=2，T=4，你就可以跳2步、3步或4步。你从第一个格子起跳，必须跳到最后一个格子上，请你输出最多可以获得的金块的总价值。 【输入格式】 第一行是格子个数n(n＜1000)；第二行是S和T，保证T大于S(2≤S＜T≤10)； 第三行是每个格子上的金块价值Pi(Pi＜10000)。 【输出格式】 输出最多可以获得的金块的总价值。 【输入样例】 10 2 3 4 5 8 2 8 3 6 7 2 9 【输出样例】 36 样例说明：跳1、3、5、8、10，总价值：4+8+8+7+9=36 package 练习; public class 抢金块 { public static void main(String[] args) { //c语言 // int n,S,T,v[1001],dp[1001]={0}; // scanf(\"%d%d%d\",&n,&S,&T); // // for(int i = 1;i0){ // dp[i] = max(dp[i],dp[i-j]+v[i]); // } // } // } // printf(\"%d\",dp[n]); // return 0; } } 2. 银行家算法 package 练习; import java.util.Scanner; public class 银行家算法 { static int[][] Max;// 进程需求资源的最大数目 static int[] Available;// 系统现有资源 static int[][] Allocation;// 进程现有资源数目 static int[][] Need;// 进程还需求的资源数 static int[][] Request;// 第i个进程请求j类资源的数目 static int[] SafeQueen;// 安全序列 static int N, M;// n个进程m种资源 public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.println(\"进程数量：\"); N = in.nextInt(); System.out.println(\"资源种类：\"); M = in.nextInt(); Max = new int[N][M]; Available = new int[M]; Allocation = new int[N][M]; Need = new int[N][M]; Request = new int[N][M]; SafeQueen = new int[N]; init(); bank(); } public static void init() { Scanner in = new Scanner(System.in); // Max for (int i = 0; i Max[i][j]) { System.out.println(\"资源的数量输入不合法\"); j = 0; continue; } Allocation[i][j] = tmp; Need[i][j] = Max[i][j] - tmp; } } } private static void bank() { System.out.println(\"---------------------------------\"); System.out.print(\"第几个进程要请求资源：\"); Scanner in = new Scanner(System.in); int index = in.nextInt() - 1; System.out.println(\"输入请求各资源的数目，一行输入空格隔开\"); int flagA = 0, flagB = 0; for (int j = 0; j Need[index][j]) flagA = 1; if (Request[index][j] > Available[j]) flagB = 1; } if (flagA == 1 || flagB == 1) { System.out.println(\"申请资源失败\"); return; } for (int j = 0; j \"); System.out.print(SafeQueen[N - 1] + 1); System.out.println(\"完成该申请后的资源分配表如下：\"); showData(); System.out.println(\"-----------------------\"); System.out.println(\"继续申请请求请输入 1\"); String s = in.next(); if (s.equals(\"1\")) bank(); } else { for (int j = 0; j work[j]) fffflag = 1; } if (fffflag == 1) continue; Finish[i] = true; count++; SafeQueen[count - 1] = i; for (int j = 0; j N) break; } if (count == N) { for (int j = 0; j 3. 硬币问题 package 练习; import java.util.Scanner; public class 硬币问题 { public static void main(String[] args) { int num,N,coin[]=new int[10],mins=0x7fffffff; num = 3; Scanner scanner = new Scanner(System.in); for(int i = 0;imins?mins:coin[i]; } N=5; int[] dp = new int[10]; for(int i = mins ;i=0){ if(i==coin[j]){min=1;break;}//如果刚好等于面值，那么这肯定是最佳的 if(dp[i-coin[j]]>0)min = dp[i-coin[j]]+14. 冰雹数 任意给定一个正整数N， 如果是偶数，执行： N / 2 如果是奇数，执行： N * 3 + 1 生成的新的数字再执行同样的动作，循环往复。 通过观察发现，这个数字会一会儿上升到很高， 一会儿又降落下来。 就这样起起落落的，但最终必会落到“1” 这有点像小冰雹粒子在冰雹云中翻滚增长的样子。 比如N=9 9,28,14,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1 可以看到，N=9的时候，这个“小冰雹”最高冲到了52这个高度。 输入格式： 一个正整数N（Npackage 七届JavaC组蓝桥杯; import java.util.Scanner; public class 冰雹数 { public static void main(String[] args) { int maxNum,maxHeight = -1; Scanner scanner = new Scanner(System.in); maxNum = scanner.nextInt(); // for(int i=1;i maxHeight){ maxHeight = n; } n = transform(n); } // } System.out.print(n+\"\\n\"); System.out.println(maxHeight); } public static int transform(int num){ if(num % 2 == 0){ return num/2; }else{ return num*3 + 1; } } } 5. 凑算式 凑算式 B DEF A + --- + ------- = 10 C GHI （如果显示有问题，可以参见【图1.jpg】） 这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。 比如： 6+8/3+952/714 就是一种解法， 5+3/1+972/486 是另一种解法。 这个算式一共有多少种解法？ package 七届JavaC组蓝桥杯; public class 凑算式 { public static int num = 0; public static boolean visited[] = new boolean[10]; public static int permutation[] = new int[10]; public static void main(String[] args) { getPermutation(1); System.out.println(num); } public static void getPermutation(int level){ if(level == 10){ check(); return; } for(int i=1;i6. 搭积木 小明最近喜欢搭数字积木， 一共有10块积木，每个积木上有一个数字，0~9。 搭积木规则： 每个积木放到其它两个积木的上面，并且一定比下面的两个积木数字小。 最后搭成4层的金字塔形，必须用完所有的积木。 下面是两种合格的搭法： 0 1 2 3 4 5 6 7 8 9 0 3 1 7 5 2 9 8 6 4 请你计算这样的搭法一共有多少种？ package 七届JavaC组蓝桥杯; public class 搭积木 { public static int num = 0; public static boolean visited[] = new boolean[10]; public static int permutation[] = new int[10]; public static int n[]={1,2,2,3,3,3}; public static void main(String[] args) { getPermutation(1); System.out.println(num); } public static void getPermutation(int level){ if(level == 10){ check(); return; } for(int i=1;i permutation[i+n[i]] || permutation[i] > permutation[i+n[i]+1]) return; } num++; } } 7. 分小组 9名运动员参加比赛，需要分3组进行预赛。 有哪些分组的方案呢？ 我们标记运动员为 A,B,C,... I 下面的程序列出了所有的分组方法。 该程序的正常输出为： ABC DEF GHI ABC DEG FHI ABC DEH FGI ABC DEI FGH ABC DFG EHI ..... (以下省略，总共560行)。 package 七届JavaC组蓝桥杯; public class 分小组 { public static int total; public static void main(String[] args) { int[] a = new int[9]; a[0] = 1; for(int b=1;b8. 密码脱落 X星球的考古学家发现了一批古代留下来的密码。 这些密码是由A、B、C、D 四种植物的种子串成的序列。 仔细分析发现，这些密码串当初应该是前后对称的（也就是我们说的镜像串）。 由于年代久远，其中许多种子脱落了，因而可能会失去镜像的特征。 你的任务是： 给定一个现在看到的密码串，计算一下从当初的状态，它要至少脱落多少个种子，才可能会变成现在的样子。 输入一行，表示现在看到的密码串（长度不大于1000） 要求输出一个正整数，表示至少脱落了多少个种子。 例如，输入： ABCBA 则程序应该输出： 0 再例如，输入： ABDCDCBABC 则程序应该输出： 3 package 七届JavaC组蓝桥杯; import java.util.Scanner; /** * 此题可以用动态规划与最长公共子序列得出答案， * 也可以用普通的递归遍历或者加上贪心算法，使程序的时间复杂度缩小到O(n^2) * 这里选择普通的递归遍历 * @author Bermuda * */ public class 密码脱落 { public static int length; public static char[] s; public static void main(String[] args) { Scanner scanner = new Scanner(System.in); s = scanner.nextLine().toCharArray(); length = s.length; recursion(0, length-1, 0); System.out.println(length); } public static void recursion(int start,int end,int total){ if(start >= end){ length = length 9. 平方怪圈 如果把一个正整数的每一位都平方后再求和，得到一个新的正整数。 对新产生的正整数再做同样的处理。 如此一来，你会发现，不管开始取的是什么数字， 最终如果不是落入1，就是落入同一个循环圈。 请写出这个循环圈中最大的那个数字。 package 七届JavaC组蓝桥杯; public class 平方怪圈 { public static void main(String[] args) { int num = 60; for(int i=0;i10. 有奖猜谜 小明很喜欢猜谜语。 最近，他被邀请参加了X星球的猜谜活动。 每位选手开始的时候都被发给777个电子币。 规则是：猜对了，手里的电子币数目翻倍， 猜错了，扣除555个电子币, 扣完为止。 小明一共猜了15条谜语。 战果为：vxvxvxvxvxvxvvx 其中v表示猜对了，x表示猜错了。 请你计算一下，小明最后手里的电子币数目是多少。 package 七届JavaC组蓝桥杯; public class 有奖猜谜 { public static void main(String[] args) { int init = 777; char[] key = \"vxvxvxvxvxvxvvx\".toCharArray(); for(int i = 0;iCopyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-03-18 20:10:33 "}}